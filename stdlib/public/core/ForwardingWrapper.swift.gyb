//===--- ForwardingWrapper.swift.gyb --------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
%{import gyb}%

//===--- ForwardingWrapper ------------------------------------------------===//

/// A type that forwards its implementation to an instance of `Base`.
///
/// Typical usage is to create protocol extensions of ForwardingWrapper
/// constrained on other conformances of `Self` and `Base`.
public protocol ForwardingWrapper {
  associatedtype Base
  var base: Base { get }
}

//===--- Comparable forwarding --------------------------------------------===//

/// Comparable -> Comparable wrappers just forward to the base implementation
public extension ForwardingWrapper where Self : Comparable, Base : Comparable {
  static func < (lhs: Self, rhs: Self) -> Bool {
    return lhs.base < rhs.base
  }
  static func == (lhs: Self, rhs: Self) -> Bool {
    return lhs.base == rhs.base
  }
}

//===--- Collection forwarding -------------------------------===//

// FIXME: introduce refinement, DGY (Don't Gyb Yourself)
% for Bidirectional in '', 'Bidirectional':
/// A type that wraps a `${Bidirectional}Collection` and forwards most or all of
/// its API.
///
/// - Note: Some models of `${Bidirectional}CollectionWrapper` are themselves
///   models `${Bidirectional}Collection`, but some are not.
///
/// - Note: works great for random access collections as well.
///
/// - Warning: A wrapper that presents a different abstraction from the `Base`
///   collection (as opposed to merely having different `Index` types, for
///   example) must explicitly implement defaults supplied by its other
///   conformances to prevent them from having semantics that simply forward to
///   the `Base`.
public protocol ${Bidirectional}CollectionWrapper : ForwardingWrapper {
  associatedtype Base : ${Bidirectional}Collection
  var base: Base { get set }
  associatedtype Index
  associatedtype IndexDistance : SignedInteger
  associatedtype Iterator = Base.Iterator
  func _wrap(_: Base.Index) -> Index
  func _unwrap(_: Index) -> Base.Index
}

/// When the `Iterator` type matches, just forward it.
extension ${Bidirectional}CollectionWrapper where Iterator == Base.Iterator {
  public func makeIterator() -> Iterator { return base.makeIterator() }
}

/// When the `Index` type matches, wrapping/unwrapping is trivial
public extension ${Bidirectional}CollectionWrapper where Index == Base.Index {
  func _wrap(_ i: Base.Index) -> Index { return i }
  func _unwrap(_ i: Index) -> Base.Index { return i }
}

/// Forwards all the `${Bidirectional}Collection` APIs from `Base`, verbatim, but
/// with whatever Index wrapping we have chosen.
extension ${Bidirectional}CollectionWrapper {
  ${gyb.expand(
      'ForwardCollectionAPIs.swift.gyb',
      base='base',
      bidirectional=(Bidirectional != ''), 
      Element='Base.Iterator.Element')}
}

/// When the model of ${Bidirectional}CollectionWrapper is itself a Collection,
/// many of the defaults become redundant with defaults supplied by Indexable
/// et. al., so repeat them with stricter constraints to resolve the ambiguity.
extension ${Bidirectional}CollectionWrapper
where Self : ${Bidirectional}Collection {
  ${gyb.expand(
      'ForwardCollectionAPIs.swift.gyb',
      base='base',
      bidirectional=(Bidirectional != ''), 
      Element='Base.Iterator.Element')}
}
% end

/// When the model of BidirectionalCollectionWrapper is itself a
/// RandomAccessCollection, some of the defaults become redundant with defaults
/// supplied by Indexable et. al., so repeat them with stricter constraints to
/// resolve the ambiguity.
extension BidirectionalCollectionWrapper
where Self : RandomAccessCollection {
  public func index(
    _ i: Index,
    offsetBy n: IndexDistance,
    limitedBy limit: Index
  ) -> Index? {
    return base.index(
      _unwrap(i),
      offsetBy: numericCast(n),
      limitedBy: _unwrap(limit)
    ).map(_wrap)
  }
}



