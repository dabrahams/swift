//===--- AU3.swift.gyb ----------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %line-directive %t/out.swift -- %target-build-swift %t/out.swift -o %t/a.out -Onone -g
// RUN: %line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test

%{
  import gyb
}%
import StdlibUnittest

/// Implementation detail of `String` that type-erases any `UnicodeContent` into
/// one word that can live in one of the cases.
class UnicodeContentBox : FactoryInitializable {
  var utf16: AnyUInt16UnicodeView { fatalError("override me!") }
  var unicodeScalars: AnyUnicodeScalarUnicodeView { fatalError("override me!") }
  var fccNormalizedUTF16: AnyUInt16UnicodeView { fatalError("override me!") }
#if false
  var utf32: AnyUInt32UnicodeView { fatalError("override me!") }
#endif
  
#if false
  // FIXME: Can this be Random Access?  If all encodings use a single code unit
  // per ASCII character and can statelessly identify a code unit that
  // represents ASCII, then yes.  Look into, e.g. shift-JIS.
  var extendedASCII: UnicodeBidirectionalUInt32 { fatalError("override me!") }
#endif
  var characters: AnyCharacterUnicodeView { fatalError("override me!") }
  var isKnownLatin1: Bool { fatalError("override me!") }
  var isKnownASCII: Bool { fatalError("override me!") }
  var isKnownFCCNormalized: Bool { fatalError("override me!") }
  var isKnownFCDForm: Bool { fatalError("override me!") }
  var isKnownNFDNormalized: Bool { fatalError("override me!") }
  var isKnownNFCNormalized: Bool { fatalError("override me!") }

  func isLatin1() -> Bool  { fatalError("override me!") }
  func isASCII() -> Bool { fatalError("override me!") }

  class Instance<Base: UnicodeContent> : UnicodeContentBox
  where Base.UTF16View.Iterator.Element == UTF16.CodeUnit,
  Base.UnicodeScalarView.Iterator.Element == UnicodeScalar
  {
    var base: Base
    
    override var utf16: AnyUInt16UnicodeView {
      return AnyUInt16UnicodeView(base.utf16)
    }
    override var unicodeScalars: AnyUnicodeScalarUnicodeView {
      return AnyUnicodeScalarUnicodeView(base.unicodeScalars)
    }
#if false
    override var utf32: AnyUInt32UnicodeView {
      return AnyUInt32UnicodeView(base.utf32)
    }
    override var fccNormalizedUTF16: AnyUInt16UnicodeView {
      return AnyUInt16UnicodeView(base.fccNormalizedUTF16)
    }
    override var extendedASCII: UnicodeBidirectionalUInt32 {
      return base.extendedASCII
    }
    override var characters: AnyCharacters { return base.characters }
#endif
    override var isKnownLatin1: Bool { return base.isKnownLatin1 }
    override var isKnownASCII: Bool { return base.isKnownASCII }
    override var isKnownFCCNormalized: Bool { return base.isKnownFCCNormalized }
    override var isKnownFCDForm: Bool { return base.isKnownFCDForm }
    override var isKnownNFDNormalized: Bool { return base.isKnownNFDNormalized }
    override var isKnownNFCNormalized: Bool { return base.isKnownNFCNormalized }
    override func isLatin1() -> Bool  { return base.isLatin1() }
    override func isASCII() -> Bool  { return base.isASCII() }
    init(_ x: Base) {
      base = x
      super.init(fromSubclass: ())
    }
  }

  convenience init<Base: UnicodeContent>(wrapping x: Base)
  where Base.UTF16View.Iterator.Element == UTF16.CodeUnit,
  Base.UnicodeScalarView.Iterator.Element == UnicodeScalar
  {
    self.init(Instance(x))
  }
  
  init(fromSubclass: ()) {}
}

// FIXME: This conformance isn't really needed, at least so far, but it keeps us
// in line.
extension UnicodeContentBox : UnicodeContent {}

//===--- String -----------------------------------------------------------===//
public struct String {
%{
    allCases = [
      ('utf16', '_UTF16StringStorage'),
      ('latin1', '_Latin1StringStorage'),
      ('any', 'UnicodeContentBox'),
      ('cocoa', 'NSStringPayload'),
      ('small1', 'UInt61'),
      ('small2', 'UInt61'),
      ('small3', 'UInt61')
    ]
}%
  public struct Content {
    struct NSStringPayload {
      let _base: TrueReference<_NSStringCore>
    }
    internal enum Representation {
      % for tag, Payload in allCases:
    case ${tag}(${Payload})
      % end
    }
    internal var _rep: Representation
  }
  public var content: Content
}

extension String.Content.NSStringPayload {
  init(_ o: TrueReference<_NSStringCore>) {
    _base = o
  }
  
  internal var object: _NSStringCore {
    return _base.object
  }
}

// Conformance not actually needed, but it gets us a bunch of implementation for
// free.
extension String.Content.NSStringPayload : AnyUnicodeContent {
  // FIXME: implement as many of these as possible
  // public var isKnownLatin1: Bool { false }
  public var isKnownASCII: Bool { return object._fastCStringContents(0) != nil }
  // var isKnownFCCNormalized: Bool { get }
  // var isKnownFCDForm: Bool { get }
  // var isKnownNFDNormalized: Bool { get }
  // var isKnownNFCNormalized: Bool { get }
  // func isLatin1() -> Bool
  // func isASCII() -> Bool
}

extension String.Content.NSStringPayload : UnicodeContent {
  internal var _utf16: _NSStringUTF16 {
    return _NSStringUTF16(base: object)
  }
  
  public var utf16: RandomAccessUnicodeView<_NSStringUTF16> {
    return RandomAccessUnicodeView(_utf16)
  }
  
  public var fccNormalizedUTF16: AnyUInt16UnicodeView {
    return AnyUInt16UnicodeView(
      _UnicodeViews(_utf16, UTF16.self).fccNormalizedUTF16
    )
  }
  
  public var characters: AnyCharacterUnicodeView {
    return AnyCharacterUnicodeView(_UnicodeViews(_utf16, UTF16.self).characters)
  }
  
  public var unicodeScalars: AnyUnicodeScalarUnicodeView {
    return AnyUnicodeScalarUnicodeView(
      _UnicodeViews(_utf16, UTF16.self).scalars)
  }
}

/// A wrapper around `_NSStringCore` that confers `RandomAccessCollection`
/// conformance.
internal struct _NSStringUTF16 : RandomAccessCollection {
  var base: _NSStringCore
  var startIndex: Int { return 0 }
  var endIndex: Int { return base.length() }
  subscript(i: Int) -> UTF16.CodeUnit {
    return base.characterAtIndex(i)
  }
  public func withExistingUnsafeBuffer<R>(
    _ body: (UnsafeBufferPointer<UTF16.CodeUnit>) throws -> R
  ) rethrows -> R? {
    guard let baseAddress = base._fastCharacterContents() else { return nil }
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: baseAddress, count: base.length()))
  }
}


/// Case accessors
extension String.Content {
  % for tag, Payload in allCases:
  /// Either the payload of `case .${tag}`, or `nil` if that is not the current
  /// case.
  ///
  /// - Note: setting this property to nil clears the `String`
  internal var _${tag}: ${Payload}? {
    get {
      if case .${tag}(let x) = _rep { return x }
      return nil
    }
    set {
      if let v = newValue { _rep = .${tag}(v) }
      else if _${tag} != nil { self = String.Content() }
    }
  }
  % end
}

extension String : Unicode {
  public typealias Base = AnyCharacterUnicodeView
  public typealias Index = AnyCharacterUnicodeView.Index
  public typealias IndexDistance = AnyCharacterUnicodeView.IndexDistance

  // FIXME: figure out how to resolve ambiguities when we try to use the default
  // from BidirectionalCollectionWrapper.
  public mutating func _tryToReplaceSubrange<C: Collection>(
    from targetStart: Index, to targetEnd: Index, with replacement: C
  ) -> Bool
  where C.Iterator.Element == Base.Iterator.Element {
    return base._tryToReplaceSubrange(
      from: targetStart, to: targetEnd,  with: replacement)
  }
}

%{
def switch(s):
  return """switch _rep {
    case .utf16(let x):
      %(s)s
    case .latin1(let x):
      %(s)s
    case .any(let x):
      %(s)s
    case .cocoa(let x):
      %(s)s
    case .small1, .small2, .small3: fatalError("unsupported")
    }""" % locals()
  
}%

extension String.Content : UnicodeContent {
  public typealias UTF16View = AnyUInt16UnicodeView
  
  // Once we get ownership and view/slice mutation worked out, it's conceivable
  // we could detect in-place mutation of these views and avoid copying,
  // especially after an append.  In the meantime, this'll have to do.
  public var utf16: UTF16View {
    get {
      ${switch('return UTF16View(x.utf16)')}
    }
    set {
      replaceUTF16(utf16.startIndex..<utf16.endIndex, with: newValue)
    }
  }

  public typealias FCCNormalizedUTF16View = AnyUInt16UnicodeView
  public var fccNormalizedUTF16: FCCNormalizedUTF16View {
    get {
      ${switch('return FCCNormalizedUTF16View(x.fccNormalizedUTF16)')}
    }
    set {
      replaceUTF16(utf16.startIndex..<utf16.endIndex, with: newValue)
    }
  }

  public typealias UnicodeScalarView = AnyUnicodeScalarUnicodeView
  public var unicodeScalars: UnicodeScalarView {
    get {
      ${switch('return UnicodeScalarView(x.unicodeScalars)')}
    }
    set {
      replaceUTF16(
        utf16.startIndex..<utf16.endIndex, with: newValue.lazy.flatMap {
          UTF16.EncodedScalar($0)
        })
    }
  }

  public typealias CharacterView = AnyCharacterUnicodeView
  public var characters: CharacterView {
    get {
      ${switch('return CharacterView(x.characters)')}
    }
    set {
      replaceUTF16(
        utf16.startIndex..<utf16.endIndex, with: newValue.lazy.flatMap {
          $0.utf16
        })
    }
  }
  
  public func isLatin1() -> Bool { ${switch('return x.isLatin1()')} }
  public func isASCII() -> Bool { ${switch('return x.isASCII()')} }
  public var isKnownLatin1: Bool { ${switch('return x.isKnownLatin1')} }
  public var isKnownASCII: Bool {  ${switch('return x.isKnownASCII')} }
  public var isKnownFCCNormalized: Bool {
    ${switch('return x.isKnownFCCNormalized')}
  }
  public var isKnownFCDForm: Bool { ${switch('return x.isKnownFCDForm')} }
  public var isKnownNFDNormalized: Bool {
    ${switch('return x.isKnownNFDNormalized')}
  }
  public var isKnownNFCNormalized: Bool {
    ${switch('return x.isKnownNFCNormalized')}
  }
}

extension Collection where Iterator.Element == UTF16.CodeUnit {
  internal func _isLatin1() -> Bool {
    return !self.contains { $0 > 0xFF }
  }
  internal var _low8Bits : LazyMapCollection<Self, UInt8> {
    return self.lazy.map { UInt8(truncatingBitPattern: $0) }
  }
}

/// Bit packing
///
/// Packing a sequence of source integer values with a given limited bit width
/// into a single representation integer.
///
/// * Lower-valued elements are assumed to be more common than higher-valued
///   elements.  We want to optimize the representation for storing smaller
///   numbers.
///
/// * Not doing anything fancy like huffman coding here; just direct bit
///   manipulation.
///
/// * We divide the representation up into segments of `bitsPerElement` bits
///   each, starting with the low bit, storing one source value per segment.
///   That means we can't represent any elements with values wider than the bit
///   width.
///
/// * In the general case, we have a partial segment in the high order bits.  
///
/// * We don't want to spend storage on representing a length.  A contiguous run
///   of segments starting with the high order (partial) segment is considered
///   to be empty space, containing no elements.  That means we can't represent
///   any sequence whose last element would be represented as zero; it would be
///   indistinguishable from a missing element.
///
/// * For each source element `e`, we store `(e + 1) & ~(~0 << bitsPerElement)`
///   in its segment.  The result is that we cannot represent a source sequence 
///   ending with the least-common value, and the most common values are
///   still very likely to be representable in any partial segment.
extension UnsignedInteger {
  public init?<S: Sequence>(packing source: S, bitsPerElement: Self)
  where S.Iterator.Element : UnsignedInteger {
    var r: Self = 0
    var lastSegment: Self = 1
    var shift: Self = 0
    let mask = ~(0 as Self) << bitsPerElement
    for x in source {
      let x1 = numericCast(x) as Self
      if x1 & mask != 0 { return nil } // value too large to represent
      let segment = (x1 &+ 1) & ~mask
      r |= segment << shift
      if r >> shift != segment { return nil } // not enough bits
      lastSegment = segment
      shift += bitsPerElement
    }
    if lastSegment == 0 {  return nil  }
    self = r
  }
}

extension UnsignedInteger {
  public static func <<(lhs: Self, rhs: Self) -> Self {
    return Self(
      (lhs.toUIntMax() << rhs.toUIntMax()) & (~(0 as Self)).toUIntMax())
  }
  public static func >>(lhs: Self, rhs: Self) -> Self {
    return Self(
      (lhs.toUIntMax() >> rhs.toUIntMax()) & (~(0 as Self)).toUIntMax())
  }
}

/* WORKAROUND HERE
extension UnsignedInteger {
  static func _packing<S: Sequence>(_ source: S, bitsPerElement: Self) -> Self?
  where S.Iterator.Element : UnsignedInteger {
    return Self(packing: source, bitsPerElement: bitsPerElement)
  }
}
extension UInt61 {
  public init?<S: Sequence>(packing source: S, bitsPerElement: UInt61)
  where S.Iterator.Element : UnsignedInteger {
    guard let me = UInt61._packing(source, bitsPerElement: 5) else { return nil }
    self = me
  }
}
*/

extension String.Content {
  public init() { _rep = .utf16(._emptyInstance()) }

  internal var _storageID: ObjectIdentifier? {
    switch _rep {
    case .utf16(let storage):
      return ObjectIdentifier(storage)
    case .latin1(let storage):
      return ObjectIdentifier(storage)
    case .any(let storage):
      return ObjectIdentifier(storage)
    case .cocoa(let storage):
      // FIXME: don't we want to return nil in the cocoa case, since this is
      // merely used for uniqueness checking and NSString is immutable?
      return ObjectIdentifier(storage.object)
    case .small1, .small2, .small3:
      return nil
    }
  }

  /// Replaces the `target` subrange with the given UTF-16 encoded content.
  internal mutating func replaceUTF16<C: Collection>(
    _ target: Range<String.Index>, with replacement_: C
  )  
  where C.Iterator.Element == UTF16.CodeUnit {
    // Pre-count replacement, once.
    let replacement = Counted(replacement_)

    // Try to do in-place replacement
    if _fastPath(replaceUTF16InPlace(target, with: replacement)) {
      return
    }
    // Otherwise, we need to allocate new storage
    
    let head = utf16[..<target.lowerBound]
    let tail = utf16[target.upperBound...]

    // See if we can use 8-bit code units
    if replacement._isLatin1() && (
      isKnownLatin1 || head._isLatin1() && tail._isLatin1()
    ) {
      let s = _Latin1StringStorage(
        joining: head._low8Bits, replacement._low8Bits, tail._low8Bits)
      s.isKnownASCII = !s.contains { $0 > 0x7f }
      _latin1 = s
    }
    else {
      _utf16 = _UTF16StringStorage(joining: head, replacement, tail)
    }
  }
  
  internal var isMutable: Bool {
    mutating get {
      defer { _fixLifetime(self) }
      return _storageID?._liveObjectIsUniquelyReferenced() ?? true
    }
  }
  
  internal mutating func replaceUTF16InPlace<C>(
    _ target: Range<String.Index>, with replacement: Counted<C>
  ) -> Bool 
  where C.Iterator.Element == UTF16.CodeUnit {
    if !isMutable { return false }

    let t: Range<Int> = numericCast(target.lowerBound.encodedOffset)
      ..< numericCast(target.upperBound.encodedOffset)

    switch _rep {
    case .utf16(let storage):
      return storage._tryToReplaceSubrange(
        from: t.lowerBound, to: t.upperBound, with: replacement)
    case .latin1(let storage):
      return storage._tryToReplaceSubrange(
        from: t.lowerBound, to: t.upperBound,
        with: replacement.lazy.map { UInt8(truncatingBitPattern: $0) })
    case .any, .cocoa, .small1, .small2, .small3:
      return false
    }
  }
}

extension String : RangeReplaceableCollection {
  
  public init() { content = Content() }
  
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Iterator.Element == Character {
    // Fast path: the incoming characters are Unicode
    if let unicodeReplacement = replacement as? AnyUnicode {
      content.replaceUTF16(target, with: unicodeReplacement.anyContent.anyUTF16)
    }
    else {
      // Slow path: we have to reconstruct UTF-16 from Characters
      content.replaceUTF16(target, with: replacement.lazy.flatMap { $0.utf16 })
    }
  }
}

extension ObjectIdentifier {
  /// Returns true if the object identified by `self` is uniquely referenced.
  ///
  /// - Requires: the object identified by `self` exists.
  /// - Note: will only work when called from a mutating method
  internal func _liveObjectIsUniquelyReferenced() -> Bool {
    var me = self
    return withUnsafeMutablePointer(to: &me) {
      $0.withMemoryRebound(to: AnyObject.self, capacity: 1) {
        _isUnique(&$0.pointee)
      }
    }    
  }
}

//===----------------------------------------------------------------------===//
//===--- Tests ------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
var suite = TestSuite("AnyUnicode")

suite.test("UInt61.packing") {
  let five: UInt61 = 5
  // Can't represent 32 as a 5-bit value
  expectNil(UInt61(packing: CollectionOfOne(32 as UInt), bitsPerElement: 5))
  
  // The last value in the collection can't have all bits set because we can't
  // distinguish that from "no more elements are left"
  expectNil(UInt61(packing: CollectionOfOne(31 as UInt), bitsPerElement: five))

  expectEqual(
    31,
    UInt61(packing: CollectionOfOne(30 as UInt), bitsPerElement: five))

  expectEqual(
    1,
    UInt61(packing: CollectionOfOne(0 as UInt), bitsPerElement: five))

  expectEqual(
    0b11111_00000,
    UInt61(packing: [31, 30] as [UInt], bitsPerElement: five))

  expectNil(UInt61(packing: [31, 30, 31] as [UInt], bitsPerElement: five))

  expectEqual(
    0b11111_00000_11111_00000,
    UInt61(packing: [31, 30, 31, 30] as [UInt], bitsPerElement: five))

  expectEqual(
    0b1_00010_00011_00100_00110_01000_01100_01110_10010_10100_11000_11110_00000,
    UInt61(packing:
      [31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2, 1, 0] as [UInt],
      bitsPerElement: five))
  
  // There's only 1 bit left in the high-order partial segment.
  expectNil(
    UInt61(packing:
      [31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2, 1, 1] as [UInt],
      bitsPerElement: five))
}

let sample = "abcdefghijklmnopqrstuvwxyz\n"
  + "🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸\n"
  + "Σὲ 👥🥓γνωρίζω ἀπὸ τὴν κόψη χαῖρε, ὦ χαῖρε, ᾿Ελευθεριά!\n"
  + "Οὐχὶ ταὐτὰ παρίσταταί μοι γιγνώσκειν, ὦ ἄνδρες ᾿Αθηναῖοι,\n"
  + "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო\n"
  + "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по\n"
  + "  ๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่\n"
  + "ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"

suite.test("MemoryLayout") {
  expectEqual(8, MemoryLayout<String>.size)
  expectEqual(8, MemoryLayout<String>.stride)
}

suite.test("InplaceViewMutation") {
  var s = String(sample)
  var s1 = s
  expectEqualSequence(s.content.unicodeScalars, s1.content.unicodeScalars)
  s.content.unicodeScalars.removeLast(1)
  expectEqualSequence(
    s.content.unicodeScalars, s1.content.unicodeScalars.dropLast()
  )
}

suite.test("ViewValueSemantics") {
  var u16 = String(sample).content.utf16
  let u2 = u16
  let snapshot = Array(u2)

  // Unwrap the view
  let wrapped = u16.base2 as! AnyUInt16UnicodeView.Adapter<
    RandomAccessUnicodeView<_UTF16StringStorage>>
  
  // Tunnel all the way to the underlying storage, which has reference
  // semantics.  FIXME: there should be no way for the user to do this!
  var storage: _UTF16StringStorage = wrapped.base.base
  storage.removeLast(1)                   
  expectFalse(snapshot.elementsEqual(u2))
  expectEqualSequence(storage, u2) 
  expectEqualSequence(storage, u16)

  // However, mutating u16 makes a copy
  u16.removeLast()
  expectEqualSequence(storage, u2) 
  expectEqualSequence(storage.dropLast(), u16)
  // FIXME: something in the collection forwarding stack is not forwarding
  // _tryToReplaceSubrange, or this test would fail.  That means we're probably
  // missing an optimization when it actually *is* OK to mutate the storage in
  // place.
}

suite.test("UTF16/smoke") {
  var s = String(sample)
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
  
  s.replaceSubrange(
    s.index(atOffset: 3)..<s.index(atOffset: 10), with: "BRAK")
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())

  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: "---bl\u{f8}\u{f8}g---"
  )
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
}

suite.test("Latin1/smoke") {
  var s = String(
    sample.unicodeScalars.lazy.filter { $0.value < 0x100 }.map {
      Character($0)
    })
  expectNotNil(s.content._latin1)
  expectTrue(s.content.isKnownLatin1)
  expectTrue(s.content.isLatin1())
  expectEqual(!s.content.utf16.contains { $0 > 0x7f }, s.content.isKnownASCII)
  expectEqual(!s.content.utf16.contains { $0 > 0x7f }, s.content.isASCII())
  
  s.replaceSubrange(s.index(atOffset: 3)..<s.index(atOffset: 10), with: "BRAK")
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))
  expectTrue(s.content.isKnownLatin1)
  expectTrue(s.content.isLatin1())
  expectTrue(s.content.isKnownASCII)
  expectTrue(s.content.isASCII())
  
  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: "---bl\u{f8}\u{f8}g---"
  )
  expectNotNil(s.content._latin1)
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
  expectTrue(s.content.isKnownLatin1)
  expectTrue(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
  
  s.replaceSubrange(
    s.index(atOffset: 11)..<s.index(atOffset: 11),
    with: "🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸")
  expectNil(s.content._latin1)
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
  expectEqual(
    "abcBR---blø🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸øg---Kklm",
    Swift.String(s[..<s.index(atOffset: 25)]))
}

suite.test("RangeReplaceable/UTF16/FastPath") {
  // Exercise the case where the source text is-a Unicode.
  var s = String(sample)
  s.replaceSubrange(
    s.index(atOffset: 3)..<s.index(atOffset: 10), with: String("BRAK"))
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))

  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: String("---bl\u{f8}\u{f8}g---")
  )
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
}

suite.test("RangeReplaceable/Latin1/FastPath") {
  // Exercise the case where the source text is-a Unicode.
  var s = String(
    sample.unicodeScalars.lazy.filter { $0.value < 0x100 }.map {
      Character($0)
    })
  s.replaceSubrange(
    s.index(atOffset: 3)..<s.index(atOffset: 10), with: String("BRAK"))
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))

  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: String("---bl\u{f8}\u{f8}g---")
  )
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
}

suite.test("Bidirectional/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeView(
    _UnicodeViews(Array(sample.utf16), ValidUTF16.self).scalars)
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedOffset = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedOffset
    expectLT(lastEncodedOffset, o)
    lastEncodedOffset = o
  }
}

suite.test("RandomAccess/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeView(
    RandomAccessUnicodeView(Array(sample.unicodeScalars)))
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedOffset = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedOffset
    expectLT(lastEncodedOffset, o)
    lastEncodedOffset = o
  }
}

runAllTests()

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
