//===--- AU3.swift.gyb ----------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %line-directive %t/out.swift -- %target-build-swift %t/out.swift -o %t/a.out -Onone
// RUN: %line-directive %t/out.swift -- %target-run %t/a.out
%{
  import gyb
}%

import StdlibUnittest

public protocol UnicodeView : BidirectionalCollection {
  func _wrap(_: Index) -> AnyUnicodeIndex_
  func _unwrap(_: AnyUnicodeIndex_) -> Index
}

//===--- AnyUnicodeIndex --------------------------------------------------===//

/// Type eraser for indices into type-erased unicode views.
///
/// Not the underlying index, but a wrapper that UnicodeViews can create for it.
public protocol AnyUnicodeIndex_ {
  var encodedPosition: Int64 { get }
  func isLess(than other: AnyUnicodeIndex_) -> Bool
  func isEqual(to other: AnyUnicodeIndex_) -> Bool
}

/// Default support for comparison
public extension AnyUnicodeIndex_ where Self : Comparable {
  func isLess(than other: AnyUnicodeIndex_) -> Bool {
    if let o = other as? Self {
      return self < o
    }
    return self.encodedPosition < other.encodedPosition
  }
  func isEqual(to other: AnyUnicodeIndex_) -> Bool {
    if let o = other as? Self {
      return self == o
    }
    return self.encodedPosition == other.encodedPosition
  }
}

/// ForwardingWrapper for instances of AnyUnicodeIndex_ that makes it a suitable
/// Index type (Comparable has self-requirements).
public struct AnyUnicodeIndex : Comparable {
  public var encodedPosition: Int64 { return base.encodedPosition }
  public var base: AnyUnicodeIndex_
  public init(_ base: AnyUnicodeIndex_) { self.base = base }
  public static func < (lhs: AnyUnicodeIndex, rhs: AnyUnicodeIndex) -> Bool {
    return lhs.base.isLess(than: rhs.base)
  }
  public static func == (lhs: AnyUnicodeIndex, rhs: AnyUnicodeIndex) -> Bool {
    return lhs.base.isEqual(to: rhs.base)
  }
}
//===----------------------------------------------------------------------===//


//===--- AnyUnicodeView ---------------------------------------------------===//
/// Type-eraser bidirectional collections with index<->code unit offsets
public protocol AnyUnicodeView_ {
  typealias IndexDistance = Int64
  var startIndex: AnyUnicodeIndex_ { get }
  var endIndex: AnyUnicodeIndex_ { get }
  func formIndex(after: inout AnyUnicodeIndex_)
  func index(after: AnyUnicodeIndex_) -> AnyUnicodeIndex_
  func formIndex(before: inout AnyUnicodeIndex_)
  func index(before: AnyUnicodeIndex_) -> AnyUnicodeIndex_
  func formIndex(_ i: inout AnyUnicodeIndex_, offsetBy: Int64)
  func index(_ i: AnyUnicodeIndex_, offsetBy: Int64) -> AnyUnicodeIndex_
  func index(
    _ i: AnyUnicodeIndex_,
    offsetBy n: Int64,
    limitedBy limit: AnyUnicodeIndex_
  ) -> AnyUnicodeIndex_?
  func distance(from i: AnyUnicodeIndex_, to j: AnyUnicodeIndex_) -> Int64
  var count: Int64 { get }
  var underestimatedCount: Int { get }
}

/// Wrappers that present some `AnyUnicodeView_` instance as a
/// `BidirectionalCollection` unwrap indices and forward all implementation to
/// base
public extension ForwardingWrapper
where Base == AnyUnicodeView_,
Self : BidirectionalCollection, Self.Index == AnyUnicodeIndex {
  // TODO: Forward Iterators
  ${gyb.expand(
    '../../stdlib/public/core/ForwardCollectionAPIs.swift.gyb',
      base='base', Element=None)}
  
  func _wrap(_ x: AnyUnicodeIndex_) -> AnyUnicodeIndex {
    return AnyUnicodeIndex(x)
  }
  func _unwrap(_ x: AnyUnicodeIndex) -> AnyUnicodeIndex_ {
    return x.base
  }
}


/// Wrappers that present some `UnicodeView` as an `AnyUnicodeView_` forward all
/// implementations by using `base` to `wrap`/`unwrap` indices and `numericCast`
/// to translate `IndexDistance`s.
public extension BidirectionalCollectionWrapper
where Base : UnicodeView, Self : AnyUnicodeView_ {
  func _wrap(_ i: Base.Index) -> AnyUnicodeIndex_ {
    return base._wrap(i)
  }
  func _unwrap(_ i: AnyUnicodeIndex_) -> Base.Index {
    return base._unwrap(i)
  }
}

/// An adapter that presents any `RandomAccessCollection` as a `UnicodeView` by
/// adding a standard model of AnyUnicodeIndex_ and a corresponding pair of
/// wrap/unwrap functions.
///
/// This adapter assumes that if you have a view of unicode that is random
/// access, there must be one element per code unit.
public struct
MappedViewOfUnicodeCodeUnits<Base : RandomAccessCollection>
: BidirectionalCollectionWrapper, UnicodeView {
  public var base: Base

  // FIXME: the compiler needs deduction help here, but shouldn't
  public typealias Index = Base.Index
  public typealias IndexDistance = Base.IndexDistance
  
  public struct AnyIndex : AnyUnicodeIndex_, ForwardingWrapper, Comparable {
    public var base: Base.Index
    var encodedPosition_: Base.IndexDistance
    public var encodedPosition: Int64 {
      return numericCast(encodedPosition_)
    }
  }
  
  public func _wrap(_ i: Index) -> AnyUnicodeIndex_ {
    return AnyIndex(base: i, encodedPosition_: base.offset(of: i))
  }
  public func _unwrap(_ i: AnyUnicodeIndex_) -> Index {
    return (i as? AnyIndex).map { $0.base }
    ?? base.index(atOffset: i.encodedPosition)
  }
}

// Generate wrappers for specific element types.
% for Element in ('UInt16', 'UInt32', 'UnicodeScalar', 'Character'):

//===--- Any${Element}Iterator --------------------------------------------===//
/// Type-eraser for Iterators over ${Element}s
public protocol Any${Element}Iterator_ {
  mutating func next() -> ${Element}?
}

public struct Any${Element}Iterator : IteratorProtocol {
  public var base: Any${Element}Iterator_
  public init(_ base: Any${Element}Iterator_) { self.base = base }
  public mutating func next() -> ${Element}? { return base.next() }

  public struct Adapter<Base : IteratorProtocol> : Any${Element}Iterator_
  where Base.Element == ${Element}
  {
    public mutating func next() -> ${Element}? { return base.next() }
    public var base: Base
  }
}

/// Wrappers that present a base `Sequence` as an `AnyUnicodeView_` adapt and
/// forward the base's `iterator`.
public extension BidirectionalCollectionWrapper
where Self : AnyUnicodeView_, Base.Iterator.Element == ${Element} {
  func makeIterator() -> Any${Element}Iterator_ {
    return Any${Element}Iterator.Adapter<Base.Iterator>(
      base: base.makeIterator())
  }
}
//===----------------------------------------------------------------------===//

//===--- Any${Element}UnicodeView -----------------------------------------===//

/// Type eraser for `UnicodeView`s with elements of type ${Element}.
public protocol Any${Element}UnicodeView_ : AnyUnicodeView_ {
  func makeIterator() -> Any${Element}Iterator_
  subscript(_: AnyUnicodeIndex_) -> ${Element} { get }
  func withExistingUnsafeBuffer<R>(
    _ body: (UnsafeBufferPointer<${Element}>) throws -> R
  ) rethrows -> R?
  var first: ${Element}? { get }
  var last: ${Element}? { get }
  func map<T>(_ transform: (${Element}) throws -> T) rethrows -> [T]
  func filter(_ inResult: (${Element}) throws -> Bool) rethrows -> [${Element}]
  func forEach(_ body: (${Element}) throws -> Void) rethrows
  func _copyToContiguousArray() -> ContiguousArray<${Element}>
}

public struct Any${Element}UnicodeView
   : BidirectionalCollection, ForwardingWrapper {
  public typealias Index = AnyUnicodeIndex
  public typealias IndexDistance = Int64
  public typealias Iterator = Any${Element}Iterator
  public func makeIterator() -> Any${Element}Iterator {
    return Any${Element}Iterator(base2.makeIterator())
  }
  
  % # using element_only here because all the non-element stuff is handled in
  % # one place above (where you see Element=None)
  ${gyb.expand(
    '../../stdlib/public/core/ForwardCollectionAPIs.swift.gyb',
      base='base2', element_only=True, Element=Element)}
  
  // `base` must have exactly this signature to match the needed constrained
  // `ForwardingWrapper` extension, so we compute it and store the more refined
  // existential in `base2`.
  public var base: AnyUnicodeView_ { return base2 }
  public var base2: Any${Element}UnicodeView_
}

/// Adapt any `UnicodeView` with elements of type `Element`
extension Any${Element}UnicodeView {
  /// An adaptor used to wrap `Base`
  public struct Adapter<Base_: UnicodeView>
  : Any${Element}UnicodeView_, BidirectionalCollectionWrapper  
  where Base_.Iterator.Element == ${Element} {
    public typealias IndexDistance = Int64
    public typealias Index = AnyUnicodeIndex_
    public typealias Base = Base_
    public var base: Base
  }

  /// Creates an instance that wraps `base`.
  public init<Base: UnicodeView>(_ base: Base)
  where Base.Iterator.Element == ${Element} {
    self.base2 = Adapter(base: base)
  }
  
  public init<Base : RandomAccessCollection>(_ base: Base)
  where Base.Iterator.Element == ${Element} {
    self.base2 = Adapter(base: MappedViewOfUnicodeCodeUnits(base: base))
  }
}

//===----------------------------------------------------------------------===//

% end

//===--- Adapt Swift.UnicodeView to this file's UnicodeView protocol ------===//
struct AnyUnicodeIndexAdapter<BaseView: Swift.UnicodeView>
: AnyUnicodeIndex_, ForwardingWrapper, Comparable {
  var base: BaseView.Index
  var encodedPosition: Int64 {
    return BaseView.encodedPosition(of: base)
  }
}

extension Swift.UnicodeView where Self : UnicodeView {
  typealias Self_ = Self
  
  public func _wrap(_ i: Index) -> AnyUnicodeIndex_ {
    return AnyUnicodeIndexAdapter<Self>(base: i)
  }
  public func _unwrap(_ i: AnyUnicodeIndex_) -> Index {
    return (i as? AnyUnicodeIndexAdapter<Self>).map { $0.base }
    ?? index(atEncodedPosition: i.encodedPosition)
  }
}
//===--- Adapt specific views ---------------------------------------------===//
extension _UnicodeViews.Scalars : UnicodeView {}
extension _TranscodedView : UnicodeView {}
//===----------------------------------------------------------------------===//

public protocol Unicode : _UnicodeContent, RandomAccessCollection
// where Iterator.Element == Character
{
  // poor man's constraint on Iterator.Element
  subscript(i: Index) -> Character { get } 
}

//===----------------------------------------------------------------------===//
//===--- Tests ------------------------------------------------------------===//
//===----------------------------------------------------------------------===//

let sample = "abcdefghijklmnopqrstuvwxyz\n"
  + "🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸\n"
  + "Σὲ 👥🥓γνωρίζω ἀπὸ τὴν κόψη χαῖρε, ὦ χαῖρε, ᾿Ελευθεριά!\n"
  + "Οὐχὶ ταὐτὰ παρίσταταί μοι γιγνώσκειν, ὦ ἄνδρες ᾿Αθηναῖοι,\n"
  + "გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო\n"
  + "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по\n"
  + "  ๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่\n"
  + "ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"


var suite = TestSuite("AU3")

suite.test("Bidirectional/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeView(
    _UnicodeViews(Array(sample.utf16), ValidUTF16.self).scalars)
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedPosition = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedPosition
    expectLT(lastEncodedPosition, o)
    lastEncodedPosition = o
  }
}

suite.test("RandomAccess/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeView(Array(sample.unicodeScalars))
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedPosition = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedPosition
    expectLT(lastEncodedPosition, o)
    lastEncodedPosition = o
  }
}

runAllTests()
