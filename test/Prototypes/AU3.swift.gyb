//===--- AU3.swift.gyb ----------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %line-directive %t/out.swift -- %target-build-swift %t/out.swift -o %t/a.out -Onone -g
// RUN: %line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test

%{
  import gyb
}%
import Darwin
import StdlibUnittest

% wrappingParam = 'wrapping'
% wrappingArg = 'wrapping: '


//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
/// Unicode views should conform to this protocol, which supports index
/// interchange and String type erasure.
public protocol _UnicodeViewZ : BidirectionalCollection {
  func index(atEncodedOffset: Int64) -> Index
  static func encodedOffset(of: Index) -> Int64
}

extension _UnicodeViewZ {
  /// Constructs a copy of other
  public init(_ other: Self) { self = other }
}

/// A UnicodeViewZ that is already using AnyUnicodeIndex has trivial interchange
/// with encoded offsets.
extension _UnicodeViewZ where Index == AnyUnicodeIndex {
  public func index(atEncodedOffset x: Int64) -> Index {
    return Index(encodedOffset: x)
  }
  public static func encodedOffset(of i: Index) -> Int64 {
    return i.encodedOffset
  }
}

public protocol UnicodeViewZ : _UnicodeViewZ {
  associatedtype SubSequence: _UnicodeViewZ = UnicodeViewSlice<Self>
}

public struct UnicodeViewSlice<Base: _UnicodeViewZ> : UnicodeViewZ {
  public let base: Base
  public let startIndex: Base.Index
  public let endIndex: Base.Index

  public func index(atEncodedOffset n: Int64) -> Index {
    return base.index(atEncodedOffset: n)
  }
  public static func encodedOffset(of i: Index) -> Int64 {
    return Base.encodedOffset(of: i)
  }

  public func index(after i: Index) -> Index { return base.index(after: i) }
  public func index(before i: Index) -> Index { return base.index(before: i) }
  public func distance(from i: Index, to j: Index) -> Base.IndexDistance {
    return base.distance(from: i, to: j)
  }
  public func index(i: Index, offsetBy n: Base.IndexDistance) -> Index {
    return base.index(i, offsetBy: n)
  }
  public subscript(i: Index) -> Iterator.Element {
    return base[i]
  }
  public typealias SubSequence = UnicodeViewSlice
}

extension _UnicodeViewZ where SubSequence == UnicodeViewSlice<Self> {
  public subscript(bounds: Range<Index>) -> UnicodeViewSlice<Self> {
    return UnicodeViewSlice(
      base: self, startIndex: bounds.lowerBound, endIndex: bounds.upperBound)
  }
}
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//

/// A type that presents useful views and information about Unicode content.
public protocol AnyUnicodeContentZ {
  var isKnownLatin1: Bool { get }
  var isKnownASCII: Bool { get }
  var isKnownFCCNormalized: Bool { get }
  var isKnownFCDForm: Bool { get }
  var isKnownNFDNormalized: Bool { get }
  var isKnownNFCNormalized: Bool { get }

  func isLatin1() -> Bool
  func isASCII() -> Bool

  // NOTE: this protocol will likely grow more requirements
  var anyUTF16: AnyUInt16UnicodeViewZ { get }
}


/// Default implementations
public extension AnyUnicodeContentZ {
  public var isKnownLatin1: Bool { return false }
  public var isKnownASCII: Bool { return false }
  public var isKnownFCCNormalized: Bool { return false }
  public var isKnownFCDForm: Bool {
    return isKnownFCCNormalized || isKnownNFDNormalized
  }
  public var isKnownNFDNormalized: Bool { return false }
  public var isKnownNFCNormalized: Bool { return false }
  
  public func isLatin1() -> Bool {
    return isKnownLatin1 || !anyUTF16.contains { $0 > 0xFF }
  }

  public func isASCII() -> Bool {
    return isKnownASCII || !anyUTF16.contains { $0 > 0x7f }
  }
}

/// Types that present useful views and information about Unicode content.
///
/// UnicodeStorageZ refines this protocol.
public protocol UnicodeContentZ : AnyUnicodeContentZ {
  /// A type that presents the string's UTF-16 code units
  associatedtype UTF16View : UnicodeViewZ
  // where Iterator.Element == UInt16

  /// The string's UTF-16 code units.
  ///
  /// Note: this view may contain encoding errors, if the underlying encoding is
  /// UTF16 and the source had encoding errors.
  var utf16: UTF16View { get }

  /// A type that presents the string's UTF-8 code units
  associatedtype UTF8View : UnicodeViewZ
  // where Iterator.Element == UInt8

  /// The string's UTF-8 code units.
  ///
  /// Note: this view may contain encoding errors, if the underlying encoding is
  /// UTF8 and the source had encoding errors.
  var utf8: UTF8View { get }

  /// A type that presents an FCC-normalized view of the string
  associatedtype FCCNormalizedUTF16View : UnicodeViewZ
  // where Iterator.Element == UInt16

  /// An FCC-normalized view of the string
  var fccNormalizedUTF16: FCCNormalizedUTF16View { get }

  associatedtype CharacterView : UnicodeViewZ
  // where Iterator.Element == Character

  var characters: CharacterView { get }

  /// A type that presents the string's unicode scalar values
  associatedtype UnicodeScalarView : UnicodeViewZ
  // where Iterator.Element == UnicodeScalar

  var unicodeScalars: UnicodeScalarView { get }
  
/*
  /// A type presenting ASCII-only extended grapheme clusters (`Character`s) as
  /// their (single) unicode scalar values, and presenting all other
  /// `Character`s as `nil`.
  associatedtype ASCIIOnlyView : UnicodeViewZ
  // where Iterator.Element : UInt8?
  
  var asciiOnlyView: ASCIIOnlyView { get }
*/
}

extension UnicodeContentZ where UTF16View.Iterator.Element == UTF16.CodeUnit {
  /// Satisfy AnyUnicodeContentZ requirements
  public var anyUTF16: AnyUInt16UnicodeViewZ {
    return AnyUInt16UnicodeViewZ(utf16)
  }
  public func isLatin1() -> Bool {
    return isKnownLatin1 || !utf16.contains { $0 > 0xFF }
  }

  public func isASCII() -> Bool {
    return isKnownASCII || !utf16.contains { $0 > 0x7f }
  }
}

/// Types that present Unicode content in a given encoding.
///
/// Typical models are the buffers that provide storage for String
public protocol UnicodeStorageZ : UnicodeContentZ {
  associatedtype Encoding: UnicodeEncoding
  var encoding: Encoding.Type { get }
  
  associatedtype CodeUnits : RandomAccessCollection
  // where Iterator.Element == Encoding.CodeUnit

  var isKnownValidEncoding: Bool { get }
  func isValidEncoding() -> Bool
  
  var codeUnits : CodeUnits { get }
  // func isFCCNormalized() -> Bool
}

/// Default views
public extension UnicodeStorageZ
where
  CodeUnits.Iterator.Element  == Encoding.EncodedScalar.Iterator.Element,
  CodeUnits.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element {
  var characters: _UnicodeViews<CodeUnits,Encoding>.CharacterView {
    return _UnicodeViews(codeUnits).characters
  }
}

// UTF8 presents its code units as the utf8 view
public extension UnicodeStorageZ
where
  Encoding.EncodedScalar == UTF8.EncodedScalar,
  CodeUnits.Iterator.Element  == Encoding.EncodedScalar.Iterator.Element,
  CodeUnits.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element {

  var utf8: RandomAccessUnicodeViewZ<CodeUnits> {
    return RandomAccessUnicodeViewZ(codeUnits)
  }
}

// Everybody else gets UTF8 by transcoding the underlying code units
public extension UnicodeStorageZ
where
  CodeUnits.Iterator.Element  == Encoding.EncodedScalar.Iterator.Element,
  CodeUnits.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element {

  var utf8: _TranscodedView<CodeUnits, Encoding, UTF8> {
    return _UnicodeViews(
      codeUnits, Encoding.self).transcoded(to: UTF8.self)
  }
}

// UTF32 gets a default UnicodeScalarView that injects replacement characters
// for illegal scalar values
public extension UnicodeStorageZ
where
  Encoding == UTF32,
  CodeUnits.Iterator.Element  == Encoding.EncodedScalar.Iterator.Element,
  CodeUnits.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element {

  var unicodeScalars: RandomAccessUnicodeViewZ<
    LazyMapRandomAccessCollection<CodeUnits, UnicodeScalar>
  > {
    return RandomAccessUnicodeViewZ(
      codeUnits.lazy.map {
        UnicodeScalar($0)
        ?? UnicodeScalar(0xFFFD)!
      }
    )
  }
}

// Everybody else gets a UnicodeScalarView based on transcoding to UTF32, which
// already makes any necessary corrections.
public extension UnicodeStorageZ
where
  CodeUnits.Iterator.Element  == Encoding.EncodedScalar.Iterator.Element,
  CodeUnits.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element {

  var unicodeScalars: _UnicodeViews<CodeUnits,Encoding>.Scalars {
    return _UnicodeViews(codeUnits, Encoding.self).scalars
  }
}

/// Default implementations
public extension UnicodeStorageZ {
  var isKnownValidEncoding: Bool { return false }
}

public extension UnicodeStorageZ
where UTF16View.Iterator.Element : UnsignedInteger {
  // FIXME: we'd like to put this up in the unconditional extension, but we are
  // forbidden.
  var encoding: Encoding.Type { return Encoding.self }
  
  func isLatin1() -> Bool {
    return isKnownLatin1 || !utf16.contains { $0 > 0xFF }
  }
  
  func isASCII() -> Bool {
    return isKnownASCII || !utf16.contains { $0 > 0x7f }
  }
}

public extension UnicodeStorageZ
where UTF16View.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == Encoding.EncodedScalar.Iterator.Element
{
  func isValidEncoding() -> Bool {
    return Encoding.parseForward(
      codeUnits, repairingIllFormedSequences: false
    ) { _ in }.errorCount == 0
  }
}

//===--- Defaults for Latin-1 ---------------------------------------------===//
public extension UnicodeStorageZ where Encoding == Latin1 {
  var isKnownLatin1: Bool { return true }
  var isKnownValidEncoding: Bool { return true }
  var isKnownFCCNormalized: Bool { return true }
}
  
public extension UnicodeStorageZ
where Encoding == Latin1, 
  CodeUnits.Iterator.Element == Encoding.EncodedScalar.Iterator.Element,
  CodeUnits.Iterator.Element : UnsignedInteger,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element
{
  var utf16: RandomAccessUnicodeViewZ<
    LazyMapRandomAccessCollection<CodeUnits, UInt16>
  > {
    return fccNormalizedUTF16
  }

  var utf8: RandomAccessUnicodeViewZ<CodeUnits> {
    return RandomAccessUnicodeViewZ(codeUnits)
  }
  
  /// An FCC-normalized view of the string
  var fccNormalizedUTF16: RandomAccessUnicodeViewZ<
    LazyMapRandomAccessCollection<CodeUnits, UInt16>
  > {
    return RandomAccessUnicodeViewZ(codeUnits.lazy.map { numericCast($0) })
  }
  
  var characters: RandomAccessUnicodeViewZ<
    LazyMapRandomAccessCollection<CodeUnits, Character>
  > {
    return RandomAccessUnicodeViewZ(
      codeUnits.lazy.map {
        Character(UnicodeScalar(numericCast($0) as UInt32)!)
      })
  }

  var unicodeScalars: RandomAccessUnicodeViewZ<
    LazyMapRandomAccessCollection<CodeUnits, UnicodeScalar>
  > {
    return RandomAccessUnicodeViewZ(
      codeUnits.lazy.map {
      UnicodeScalar(numericCast($0) as UInt32)!
    })
  }
}

//===--- Defaults for UTF16 and ValidUTF16 --------------------------------===//
public extension UnicodeStorageZ
where Encoding.EncodedScalar == UTF16.EncodedScalar,
  CodeUnits.Iterator.Element == UTF16.CodeUnit,
  CodeUnits.SubSequence : RandomAccessCollection,
  CodeUnits.SubSequence.Index == CodeUnits.Index,
  CodeUnits.SubSequence.SubSequence == CodeUnits.SubSequence,
  CodeUnits.SubSequence.Iterator.Element == CodeUnits.Iterator.Element {
  
  // FIXME: we should have a way to represent the validity of the encoding of
  // this result—and maybe other nice properties—in the type system.  So maybe
  // this thing should conform to UnicodeStorageZ
  var fccNormalizedUTF16
  : _UnicodeViews<CodeUnits,Encoding>.FCCNormalizedUTF16View {
    return _UnicodeViews(codeUnits, Encoding.self).fccNormalizedUTF16
  }
  
  var utf16 : RandomAccessUnicodeViewZ<CodeUnits> {
    return RandomAccessUnicodeViewZ(codeUnits)
  }
}

//===--- AnyUnicodeIndex --------------------------------------------------===//

/// Type eraser for indices into type-erased unicode views.
///
/// Not the underlying index, but a wrapper that UnicodeViews can create for it.
public protocol AnyUnicodeIndex_Z {
  var encodedOffset: Int64 { get }
  func isLess(than other: AnyUnicodeIndex_Z) -> Bool
  func isEqual(to other: AnyUnicodeIndex_Z) -> Bool
}

/// Default support for comparison
public extension AnyUnicodeIndex_Z where Self : Comparable {
  func isLess(than other: AnyUnicodeIndex_Z) -> Bool {
    if let o = other as? Self {
      return self < o
    }
    return self.encodedOffset < other.encodedOffset
  }
  func isEqual(to other: AnyUnicodeIndex_Z) -> Bool {
    if let o = other as? Self {
      return self == o
    }
    return self.encodedOffset == other.encodedOffset
  }
}

/// ForwardingWrapper for instances of AnyUnicodeIndex_Z that makes it a suitable
/// Index type (Comparable has self-requirements).
public struct AnyUnicodeIndex : Comparable {
  public var encodedOffset: Int64 { return base.encodedOffset }
  public var base: AnyUnicodeIndex_Z
  public init(_ base: AnyUnicodeIndex_Z) { self.base = base }
  public static func < (lhs: AnyUnicodeIndex, rhs: AnyUnicodeIndex) -> Bool {
    return lhs.base.isLess(than: rhs.base)
  }
  public static func == (lhs: AnyUnicodeIndex, rhs: AnyUnicodeIndex) -> Bool {
    return lhs.base.isEqual(to: rhs.base)
  }

  internal struct _OffsetAdapter
    : AnyUnicodeIndex_Z, ForwardingWrapper, Comparable {
    init(base: Int64) { self.base = base }
    var encodedOffset: Int64 { return base }
    var base: Int64
  }

  internal struct _IndexAdapter<BaseView: UnicodeViewZ>
  : AnyUnicodeIndex_Z, ForwardingWrapper, Comparable {
    var base: BaseView.Index
    var encodedOffset: Int64 {
      return BaseView.encodedOffset(of: base)
    }
  }

  public init(encodedOffset: Int64) {
    self.base = _OffsetAdapter(base: encodedOffset)
  }
}

//===----------------------------------------------------------------------===//


//===--- AnyUnicodeViewZ ---------------------------------------------------===//
/// Type-eraser for bidirectional collections with index<->code unit offsets
public protocol AnyUnicodeViewZ_ {
  typealias IndexDistance = Int64
  var startIndex: AnyUnicodeIndex_Z { get }
  var endIndex: AnyUnicodeIndex_Z { get }
  func formIndex(after: inout AnyUnicodeIndex_Z)
  func index(after: AnyUnicodeIndex_Z) -> AnyUnicodeIndex_Z
  func formIndex(before: inout AnyUnicodeIndex_Z)
  func index(before: AnyUnicodeIndex_Z) -> AnyUnicodeIndex_Z
  func formIndex(_ i: inout AnyUnicodeIndex_Z, offsetBy: Int64)
  func index(_ i: AnyUnicodeIndex_Z, offsetBy: Int64) -> AnyUnicodeIndex_Z
  func index(
    _ i: AnyUnicodeIndex_Z,
    offsetBy n: Int64,
    limitedBy limit: AnyUnicodeIndex_Z
  ) -> AnyUnicodeIndex_Z?
  func distance(from i: AnyUnicodeIndex_Z, to j: AnyUnicodeIndex_Z) -> Int64
  var count: Int64 { get }
  var underestimatedCount: Int { get }
}

/// Wrappers that present some `AnyUnicodeViewZ_` instance as a
/// `BidirectionalCollection` unwrap indices and forward all implementation to
/// base
public extension ForwardingWrapper
where Base == AnyUnicodeViewZ_,
Self : BidirectionalCollection, Self.Index == AnyUnicodeIndex {
  // TODO: Forward Iterators
  ${gyb.expand(
      '../../stdlib/public/core/ForwardCollectionAPIs.swift.gyb', base='base', Element=None)}
  
  func _wrap(_ x: AnyUnicodeIndex_Z) -> AnyUnicodeIndex {
    return AnyUnicodeIndex(x)
  }
  func _unwrap(_ x: AnyUnicodeIndex) -> AnyUnicodeIndex_Z {
    return x.base
  }
}

/// Wrappers that present some `UnicodeViewZ` as an `AnyUnicodeViewZ_` forward all
/// implementations by using `base` to `wrap`/`unwrap` indices and `numericCast`
/// to translate `IndexDistance`s.
public extension BidirectionalCollectionWrapper
where Base : UnicodeViewZ, Self : AnyUnicodeViewZ_ {
  func _wrap(_ i: Base.Index) -> AnyUnicodeIndex_Z {
    return AnyUnicodeIndex._IndexAdapter<Base>(base: i)
  }
  func _unwrap(_ i: AnyUnicodeIndex_Z) -> Base.Index {
    return (i as? AnyUnicodeIndex._IndexAdapter<Base>).map { $0.base }
    ?? base.index(atEncodedOffset: i.encodedOffset)
  }
}

// Generate wrappers for specific element types.
% for Element in ('UInt8', 'UInt16', 'UInt32', 'UnicodeScalar', 'Character'):

//===--- Any${Element}Iterator --------------------------------------------===//
/// Type-eraser for Iterators over ${Element}s
public protocol Any${Element}Iterator_ {
  mutating func next() -> ${Element}?
}

public struct Any${Element}Iterator : IteratorProtocol {
  public var base: Any${Element}Iterator_
  public init(_ base: Any${Element}Iterator_) { self.base = base }
  public mutating func next() -> ${Element}? { return base.next() }

  public struct Adapter<Base : IteratorProtocol> : Any${Element}Iterator_
  where Base.Element == ${Element}
  {
    public mutating func next() -> ${Element}? { return base.next() }
    public var base: Base
  }
}

/// Wrappers that present a base `Sequence` as an `AnyUnicodeViewZ_` adapt and
/// forward the base's `iterator`.
public extension BidirectionalCollectionWrapper
where Self : AnyUnicodeViewZ_, Base.Iterator.Element == ${Element} {
  func makeIterator() -> Any${Element}Iterator_ {
    return Any${Element}Iterator.Adapter<Base.Iterator>(
      base: base.makeIterator())
  }
}
//===----------------------------------------------------------------------===//

//===--- Any${Element}UnicodeViewZ -----------------------------------------===//

/// Type eraser for `UnicodeViewZ`s with elements of type ${Element}.
public protocol Any${Element}UnicodeViewZ_ : AnyUnicodeViewZ_ {
  func makeIterator() -> Any${Element}Iterator_
  subscript(_: AnyUnicodeIndex_Z) -> ${Element} { get }
  func withExistingUnsafeBuffer<R>(
    _ body: (UnsafeBufferPointer<${Element}>) throws -> R
  ) rethrows -> R?
  var first: ${Element}? { get }
  var last: ${Element}? { get }
  func map<T>(_ transform: (${Element}) throws -> T) rethrows -> [T]
  func filter(_ inResult: (${Element}) throws -> Bool) rethrows -> [${Element}]
  func forEach(_ body: (${Element}) throws -> Void) rethrows
  func _copyToContiguousArray() -> ContiguousArray<${Element}>
  mutating func _tryToReplaceSubrange<C: Collection>(
    from: AnyUnicodeIndex_Z, to: AnyUnicodeIndex_Z, with replacement: C
  ) -> Bool
  where C.Iterator.Element == ${Element}
}

public struct Any${Element}UnicodeViewZ
   : BidirectionalCollection, ForwardingWrapper {
  public typealias SubSequence = UnicodeViewSlice<Any${Element}UnicodeViewZ>
  public typealias Index = AnyUnicodeIndex
  public typealias IndexDistance = Int64
  public typealias Iterator = Any${Element}Iterator
  public func makeIterator() -> Any${Element}Iterator {
    return Any${Element}Iterator(base2.makeIterator())
  }
  
  % # using element_only here because all the non-element stuff is handled in
  % # one place above (where you see Element=None)
  ${gyb.expand(
      '../../stdlib/public/core/ForwardCollectionAPIs.swift.gyb', base='base2',
      element_only=True, Element=Element)}
  
  // `base` must have exactly this signature to match the needed constrained
  // `ForwardingWrapper` extension, so we compute it and store the more refined
  // existential in `base2`.
  public var base: AnyUnicodeViewZ_ { return base2 }
  public var base2: Any${Element}UnicodeViewZ_
}

/// Adapt any `UnicodeViewZ` with elements of type `Element`
extension Any${Element}UnicodeViewZ {
  /// An adaptor used to wrap `Base`
  public struct Adapter<Base_: UnicodeViewZ>
  : Any${Element}UnicodeViewZ_, BidirectionalCollectionWrapper  
  where Base_.Iterator.Element == ${Element} {
    public typealias IndexDistance = Int64
    public typealias Index = AnyUnicodeIndex_Z
    public typealias Base = Base_
    public var base: Base
  }

  /// Creates an instance that wraps `base`.
  public init<Base: UnicodeViewZ>(${wrappingParam} base: Base)
  where Base.Iterator.Element == ${Element} {
    if let me = base as? Any${Element}UnicodeViewZ { self = me }
    else { self.base2 = Adapter(base: base) }
  }
}

extension Any${Element}UnicodeViewZ : RangeReplaceableCollection {
  public init() {
    self.init(${wrappingArg}RandomAccessUnicodeViewZ(EmptyCollection()))
  }
  
  public mutating func replaceSubrange<C>(
    _ target: Range<Index>,
    with replacement: C
  ) where C : Collection, C.Iterator.Element == ${Element} {
    let r = Counted(replacement)
    // FIXME: wrappers like Counted interfere with dynamic introspection, such
    // as downcasts to AnyUnicode, that can be crucial to optimization.  This
    // problem seems solvable by giving Collections and wrappers something like
    // func encodedContent<T>(as: T.Type) -> T?
    if base2._tryToReplaceSubrange(
      from: target.lowerBound.base, to: target.upperBound.base, with: r
    ) { return }

    let newCount = count + (r.count^ - self[target].count)^
    // FIXME: Ideally we'd create new _[XXX]StringStorage for this part.  In
    // principle that would imply renaming these from Any[Type]View to
    // Any[Encoding]View, because one has to know how to get back into a
    // String representation.  For now, though, this will do.
    var newContent: [${Element}] = []
    newContent.reserveCapacity(newCount^)
    newContent.append(contentsOf: self[..<target.lowerBound])
    newContent.append(contentsOf: r)
    newContent.append(contentsOf: self[target.upperBound...])
    self = Any${Element}UnicodeViewZ(${wrappingArg}RandomAccessUnicodeViewZ(newContent))
  }
}

extension Any${Element}UnicodeViewZ : UnicodeViewZ {}

//===----------------------------------------------------------------------===//

% end

//===--- UnicodeZ ----------------------------------------------------------===//

/// Types that have an `AnyUnicodeContentZ` instance that describes their whole
/// content.
public protocol AnyUnicodeZ {
  var anyContent: AnyUnicodeContentZ { get }
}

/// Collections of `Character` that have `UnicodeContentZ`.
public protocol UnicodeZ
  : AnyUnicodeZ, BidirectionalCollection, BidirectionalCollectionWrapper
// where Iterator.Element == Character
{
  // poor man's constraint on Iterator.Element
  subscript(i: Index) -> Character { get }
  
  associatedtype Content : UnicodeContentZ
  var content: Content { get }
}

extension UnicodeZ {
  public var base: Content.CharacterView {
    get {
      return content.characters
    }
  }
  public var anyContent: AnyUnicodeContentZ { return content }
}

extension UnicodeZ where Self : RangeReplaceableCollection,
Iterator.Element == Content.CharacterView.Iterator.Element
{
  public var base: Content.CharacterView {
    get {
      return content.characters
    }
    set {
      replaceSubrange(startIndex..<endIndex, with: newValue)
    }
  }
  public var anyContent: AnyUnicodeContentZ { return content }
}

//===--- RandomAccessUnicodeViewZ ------------------------------------------===//
/// Adapts any `RandomAccessCollection` to a `UnicodeViewZ`, with
/// `encodedOffset`s equal to the number of index steps from the `startIndex`.
///
/// Computing `encodedOffset` this way is pretty safe because if the base view
/// has random access, it must have a constant number N of elements per code
/// unit, and in all the usual instances, N = 1
public struct RandomAccessUnicodeViewZ<Base_: RandomAccessCollection> {
  public typealias Base = Base_
  public var base: Base
  public init(_ base: Base) { self.base = base }
}

extension RandomAccessUnicodeViewZ : BidirectionalCollectionWrapper {
  public struct Index : ForwardingWrapper, Comparable {
    public var base: Base_.IndexDistance
  }
  public typealias IndexDistance = Base.IndexDistance
  public func _wrap(_ i: Base_.Index) -> Index {
    return Index(base: base.offset(of: i))
  }
  public func _unwrap(_ i: Index) -> Base.Index {
    return base.index(atOffset: i.base)
  }
}

extension RandomAccessUnicodeViewZ : RandomAccessCollection {}

extension RandomAccessUnicodeViewZ : UnicodeViewZ {
  public func index(atEncodedOffset position: Int64) -> Index {
    return Index(base: position^)
  }
  public static func encodedOffset(of i: Index) -> Int64 {
    return i.base^
  }
}

extension RandomAccessUnicodeView
where Iterator.Element == Base_.Iterator.Element {
  public mutating func _tryToReplaceSubrange<C: Collection>(
    from targetStart: Index, to targetEnd: Index, with replacement: C
  ) -> Bool
  where C.Iterator.Element == Iterator.Element {
    // UnicodeViews must have value semantics.  Note that this check will fail
    // to work if the view being wrapped is itself a wrapper that forwards
    // _tryToReplaceSubrange to an underlying reference type.
    if Base_.self is AnyObject.Type {
      if
      true || // WORKAROUND: https://bugs.swift.org/browse/SR-4449
      !_isUnique(&base) { return false }
    }
    return base._tryToReplaceSubrange(
      from: _unwrap(targetStart), to: _unwrap(targetEnd),  with: replacement)
  }
}
//===----------------------------------------------------------------------===//

extension _TranscodedView : UnicodeViewZ {  }
extension RandomAccessUnicodeView : UnicodeViewZ {  }
extension _UnicodeViews.FCCNormalizedUTF16View : UnicodeViewZ {}
extension _UnicodeViews.EncodedScalars : UnicodeViewZ {}
extension _UnicodeViews.Scalars : UnicodeViewZ {}
extension _UnicodeViews.CharacterView : UnicodeViewZ {}


//===----------------------------------------------------------------------===//
extension _SignedInteger {
  internal static postfix func ^ <U : _SignedInteger>(_ x: Self) -> U {
    return numericCast(x)
  }
  internal static postfix func ^ <U : UnsignedInteger>(_ x: Self) -> U {
    return numericCast(x)
  }
}
extension UnsignedInteger {
  internal static postfix func ^ <U : UnsignedInteger>(_ x: Self) -> U {
    return numericCast(x)
  }
  internal static postfix func ^ <U : SignedInteger>(_ x: Self) -> U {
    return numericCast(x)
  }
}
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//

/// Implementation detail of `String` that type-erases any `UnicodeContentZ` into
/// one word that can live in one of the cases.
class UnicodeContentZBox : FactoryInitializable {
  var utf16: AnyUInt16UnicodeViewZ { fatalError("override me!") }
  var utf8: AnyUInt8UnicodeViewZ { fatalError("override me!") }
  var unicodeScalars: AnyUnicodeScalarUnicodeViewZ { fatalError("override me!") }
  var fccNormalizedUTF16: AnyUInt16UnicodeViewZ { fatalError("override me!") }
/*
  var utf32: AnyUInt32UnicodeViewZ { fatalError("override me!") }
*/

  /*
  // FIXME: Can this be Random Access?  If all encodings use a single code unit
  // per ASCII character and can statelessly identify a code unit that
  // represents ASCII, then yes.  Look into, e.g. shift-JIS.
  var extendedASCII: UnicodeBidirectionalUInt32 { fatalError("override me!") }
*/
  var characters: AnyCharacterUnicodeViewZ { fatalError("override me!") }
  var isKnownLatin1: Bool { fatalError("override me!") }
  var isKnownASCII: Bool { fatalError("override me!") }
  var isKnownFCCNormalized: Bool { fatalError("override me!") }
  var isKnownFCDForm: Bool { fatalError("override me!") }
  var isKnownNFDNormalized: Bool { fatalError("override me!") }
  var isKnownNFCNormalized: Bool { fatalError("override me!") }

  func isLatin1() -> Bool  { fatalError("override me!") }
  func isASCII() -> Bool { fatalError("override me!") }

  class Instance<Base: UnicodeContentZ> : UnicodeContentZBox
  where Base.UTF16View.Iterator.Element == UTF16.CodeUnit,
  Base.UTF8View.Iterator.Element == UTF8.CodeUnit,
  Base.UnicodeScalarView.Iterator.Element == UnicodeScalar,
  Base.CharacterView.Iterator.Element == Character
  {
    var base: Base
    
    override var utf16: AnyUInt16UnicodeViewZ {
      return AnyUInt16UnicodeViewZ(${wrappingArg}base.utf16)
    }
    override var utf8: AnyUInt8UnicodeViewZ {
      return AnyUInt8UnicodeViewZ(${wrappingArg}base.utf8)
    }
    override var unicodeScalars: AnyUnicodeScalarUnicodeViewZ {
      return AnyUnicodeScalarUnicodeViewZ(${wrappingArg}base.unicodeScalars)
    }
/*
    override var utf32: AnyUInt32UnicodeViewZ {
      return AnyUInt32UnicodeViewZ(${wrappingArg}base.utf32)
    }
    override var fccNormalizedUTF16: AnyUInt16UnicodeViewZ {
      return AnyUInt16UnicodeViewZ(${wrappingArg}base.fccNormalizedUTF16)
    }
    override var extendedASCII: UnicodeBidirectionalUInt32 {
      return base.extendedASCII
    }
*/
    override var characters: AnyCharacterUnicodeViewZ {
      return AnyCharacterUnicodeViewZ(${wrappingArg}base.characters)
    }
    override var isKnownLatin1: Bool { return base.isKnownLatin1 }
    override var isKnownASCII: Bool { return base.isKnownASCII }
    override var isKnownFCCNormalized: Bool { return base.isKnownFCCNormalized }
    override var isKnownFCDForm: Bool { return base.isKnownFCDForm }
    override var isKnownNFDNormalized: Bool { return base.isKnownNFDNormalized }
    override var isKnownNFCNormalized: Bool { return base.isKnownNFCNormalized }
    override func isLatin1() -> Bool  { return base.isLatin1() }
    override func isASCII() -> Bool  { return base.isASCII() }
    init(_ x: Base) {
      base = x
      super.init(fromSubclass: ())
    }
  }

  convenience init<Base: UnicodeContentZ>(${wrappingParam} x: Base)
  where Base.UTF16View.Iterator.Element == UTF16.CodeUnit,
  Base.UTF8View.Iterator.Element == UTF8.CodeUnit,
  Base.UnicodeScalarView.Iterator.Element == UnicodeScalar,
  Base.CharacterView.Iterator.Element == Character
  {
    self.init(Instance(x))
  }
  
  init(fromSubclass: ()) {}
}

// FIXME: This conformance isn't really needed, at least so far, but it keeps us
// in line.
extension UnicodeContentZBox : UnicodeContentZ {}

//===--- String -----------------------------------------------------------===//
public struct String {
%{
    allCases = [
      ('utf16', '_UTF16StringStorage'),
      ('latin1', '_Latin1StringStorage'),
      ('any', 'UnicodeContentZBox'),
      ('cocoa', 'NSStringPayload'),
      ('inline5or6', 'Inline5or6'),
      ('inline7or16', 'Inline7or16'),
    ]
}%
  
  public struct Content {
    internal enum Representation {
      % for tag, Payload in allCases:
    case ${tag}(${Payload})
      % end
    }
    internal init(_ representation: Representation) {
      self._rep = representation
    }
    internal var _rep: Representation
  }
  public var content: Content
}

/// Case accessors
extension String.Content {
  % for tag, Payload in allCases:
  /// Either the payload of `case .${tag}`, or `nil` if that is not the current
  /// case.
  ///
  /// - Note: setting this property to nil clears the `String`
  internal var _${tag}: ${Payload}? {
    get {
      if case .${tag}(let x) = _rep { return x }
      return nil
    }
    set {
      if let v = newValue { _rep = .${tag}(v) }
      else if _${tag} != nil { self = String.Content() }
    }
  }
  % end
}

//===--- Inline5or6/Inline7or16 --------------------------------------------===//
extension String.Content {
  static let packingTable: StaticString
  = "eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"

  typealias Packed = PackedUnsignedIntegers<UInt60, UInt16>
  
  static func _pack<Source: Collection>(
    utf16 source: Source, bitsPerElement: UInt16
  ) -> Packed?
  where Source.Iterator.Element == UTF16.CodeUnit {
    return Packed(
      bitsPerElement < 7 ?
      String.Content.packingTable.withUTF8Buffer { table in
        source.lazy.map { (x: UInt16) -> UInt16 in 
          numericCast(table.lazy.map { UInt16($0) }.index(of: x) ?? 0xFF)
        }
      }:
      source.lazy.map { 
        [ mask = UInt16(truncatingBitPattern: ~0 << UInt32(bitsPerElement)) ]
        (x: UInt16) -> UInt16 in (x & mask) | (x &- 32) & ~mask
      },
      bitsPerElement: numericCast(bitsPerElement)
    )
  }
  
  static func _unpack(
    bits: UInt61, bitsPerElement: UInt16
  ) -> LazyMapRandomAccessCollection<String.Content.Packed, UInt16> {
    let source = String.Content.Packed(
      representation: numericCast(bits & (~(0 as UInt61) >> 1)),
      bitsPerElement: numericCast(bitsPerElement)
    )
    return bitsPerElement < 7
    ? String.Content.packingTable.withUTF8Buffer {
      table in source.lazy.map {
        (x: UInt16) -> UInt16 in UInt16(table[numericCast(x)])
      }
    }
    : source.lazy.map { 
      [ mask = UInt16(truncatingBitPattern: ~0 << UInt32(bitsPerElement)) ]
      (x: UInt16) -> UInt16 in
      (x &+ 32) & ~mask
    }
  }
}
  
% for (N,W) in (5,6), (7,16):
extension String.Content {
  struct Inline${N}or${W} {
    let bits: UInt61
  }
}


extension String.Content.Inline${N}or${W} {
  init?<Source: Collection>(utf16 source: Source)
  where Source.Iterator.Element == UTF16.CodeUnit {
    if let c = String.Content._pack(utf16: source, bitsPerElement: ${W}) {
      bits = numericCast(c.representation) | (1 as UInt61) << 60
    }
    else if let c = String.Content._pack(utf16: source, bitsPerElement: ${N}) {
      bits = numericCast(c.representation) 
    }
    else { return nil }
  }

  var bitsPerElement: Int { return bits >> 60 == 0 ? ${N} : ${W} }
}

extension String.Content.Inline${N}or${W} : AnyUnicodeContentZ {
  // FIXME: implement as many of these as possible
  // public var isKnownLatin1: Bool { false }
  public var isKnownASCII: Bool { return bitsPerElement <= 7 }
  // var isKnownFCCNormalized: Bool { get }
  // var isKnownFCDForm: Bool { get }
  // var isKnownNFDNormalized: Bool { get }
  // var isKnownNFCNormalized: Bool { get }
  // func isLatin1() -> Bool
  // func isASCII() -> Bool
}

extension String.Content.Inline${N}or${W} : UnicodeContentZ {
  public typealias _UTF16View = LazyMapRandomAccessCollection<
    String.Content.Packed, UTF16.CodeUnit
  >
  
  internal var _utf16: _UTF16View {
    return String.Content._unpack(
      bits: bits, 
      bitsPerElement: numericCast(self.bitsPerElement)
    )
  }

  public var utf16: RandomAccessUnicodeViewZ<_UTF16View> {
    return RandomAccessUnicodeViewZ(_utf16)
  }
  
  public var utf8: AnyUInt8UnicodeViewZ {
    return bitsPerElement < 8
    ? AnyUInt8UnicodeViewZ(${wrappingArg}
      RandomAccessUnicodeViewZ(
        _utf16.lazy.map {
          UInt8(truncatingBitPattern: $0) }))
    : AnyUInt8UnicodeViewZ(${wrappingArg}
        _UnicodeViews(_utf16, UTF16.self).transcoded(to: UTF8.self))
  }
  
  public var fccNormalizedUTF16: AnyUInt16UnicodeViewZ {
    return bitsPerElement <= 8
    ? AnyUInt16UnicodeViewZ(${wrappingArg}utf16)
    : AnyUInt16UnicodeViewZ(${wrappingArg}
      _UnicodeViews(_utf16, UTF16.self).fccNormalizedUTF16
    )
  }
  
  public var characters: AnyCharacterUnicodeViewZ {
    if bitsPerElement <= 8 || !_utf16.contains(where: { $0 >= 0x300 }) {
      let _characters = _utf16.lazy.map {
        // FIXME: Use _unchecked: in stdlib
        Character(UnicodeScalar(UInt32($0))!)
      }
      return AnyCharacterUnicodeViewZ(${wrappingArg}RandomAccessUnicodeViewZ(_characters))
    }
    return AnyCharacterUnicodeViewZ(${wrappingArg}
      _UnicodeViews(_utf16, UTF16.self).characters)
  }
  
  public var unicodeScalars: AnyUnicodeScalarUnicodeViewZ {
    if bitsPerElement <= 8 || !_utf16.contains(where: { $0 >= 0xD800 }) {
      return AnyUnicodeScalarUnicodeViewZ(${wrappingArg}
      RandomAccessUnicodeViewZ(
        _utf16.lazy.map {
            // FIXME: Use _unchecked: in stdlib
            UnicodeScalar(UInt32($0))!
          }))
    }
    return AnyUnicodeScalarUnicodeViewZ(${wrappingArg}
      _UnicodeViews(_utf16, UTF16.self).scalars)
  }
}

% end


//===--- NSStringPayload --------------------------------------------------===//
extension String.Content {
  struct NSStringPayload {
    let _base: TrueReference<_NSStringCore>
  }
}

extension String.Content.NSStringPayload {
  init(_ o: TrueReference<_NSStringCore>) {
    _base = o
  }
  
  internal var object: _NSStringCore {
    return _base.object
  }
}

extension String.Content.NSStringPayload : AnyUnicodeContentZ {
  // FIXME: implement as many of these as possible
  // public var isKnownLatin1: Bool { false }
  public var isKnownASCII: Bool { return object._fastCStringContents(0) != nil }
  // var isKnownFCCNormalized: Bool { get }
  // var isKnownFCDForm: Bool { get }
  // var isKnownNFDNormalized: Bool { get }
  // var isKnownNFCNormalized: Bool { get }
  // func isLatin1() -> Bool
  // func isASCII() -> Bool
}

extension String.Content.NSStringPayload : UnicodeContentZ {
  internal var _utf16: _NSStringUTF16 {
    return _NSStringUTF16(base: object)
  }
  
  public var utf16: RandomAccessUnicodeViewZ<_NSStringUTF16> {
    return RandomAccessUnicodeViewZ(_utf16)
  }
  
  public var utf8: _TranscodedView<_NSStringUTF16, UTF16, UTF8> {
    return _TranscodedView<_NSStringUTF16, UTF16, UTF8>(_utf16)
  }
  
  public var fccNormalizedUTF16: AnyUInt16UnicodeViewZ {
    return AnyUInt16UnicodeViewZ(${wrappingArg}
      _UnicodeViews(_utf16, UTF16.self).fccNormalizedUTF16
    )
  }
  
  public var characters: AnyCharacterUnicodeViewZ {
    return AnyCharacterUnicodeViewZ(${wrappingArg}_UnicodeViews(_utf16, UTF16.self).characters)
  }
  
  public var unicodeScalars: AnyUnicodeScalarUnicodeViewZ {
    return AnyUnicodeScalarUnicodeViewZ(${wrappingArg}
      _UnicodeViews(_utf16, UTF16.self).scalars)
  }
}

/// A wrapper around `_NSStringCore` that confers `RandomAccessCollection`
/// conformance.
internal struct _NSStringUTF16 : RandomAccessCollection {
  var base: _NSStringCore
  var startIndex: Int { return 0 }
  var endIndex: Int { return base.length() }
  subscript(i: Int) -> UTF16.CodeUnit {
    return base.characterAtIndex(i)
  }
  public func withExistingUnsafeBuffer<R>(
    _ body: (UnsafeBufferPointer<UTF16.CodeUnit>) throws -> R
  ) rethrows -> R? {
    guard let baseAddress = base._fastCharacterContents() else { return nil }
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: baseAddress, count: base.length()))
  }
}
//===----------------------------------------------------------------------===//


extension String : UnicodeZ {
  public typealias Base = AnyCharacterUnicodeViewZ
  public typealias Index = AnyCharacterUnicodeViewZ.Index
  public typealias IndexDistance = AnyCharacterUnicodeViewZ.IndexDistance

  public struct SubSequence {
    public typealias Base = RangeReplaceableBidirectionalSlice<String>
    public var base: Base
  }

  public subscript(bounds: Range<Index>) -> SubSequence {
    get {
      return SubSequence(base:
        RangeReplaceableBidirectionalSlice(base: self, bounds: bounds))
    }
    set {
      fatalError("implement me!")
    }
  }

  // FIXME: figure out how to resolve ambiguities when we try to use the default
  // from BidirectionalCollectionWrapper.
  public mutating func _tryToReplaceSubrange<C: Collection>(
    from targetStart: Index, to targetEnd: Index, with replacement: C
  ) -> Bool
  where C.Iterator.Element == Base.Iterator.Element {
    return base._tryToReplaceSubrange(
      from: targetStart, to: targetEnd,  with: replacement)
  }
}

%{
def switch(s):
  return """switch _rep {
    case .utf16(let x):
      %(s)s
    case .latin1(let x):
      %(s)s
    case .any(let x):
      %(s)s
    case .cocoa(let x):
      %(s)s
    case .inline5or6(let x):
      %(s)s
    case .inline7or16(let x):
      %(s)s
    }""" % locals()
}%

extension String.Content : UnicodeContentZ {
  // Once we get ownership and view/slice mutation worked out, it's conceivable
  // we could detect in-place mutation of these views and avoid copying,
  // especially after an append.  In the meantime, this'll have to do.
  
  public typealias UTF16View = AnyUInt16UnicodeViewZ
  public var utf16: UTF16View {
    get {
      ${switch('return UTF16View('+wrappingArg+'x.utf16)')}
    }
    set {
      replaceUTF16(utf16.startIndex..<utf16.endIndex, with: newValue)
    }
  }

  public typealias UTF8View = AnyUInt8UnicodeViewZ
  public var utf8: UTF8View {
    get {
      ${switch('return UTF8View('+wrappingArg+'x.utf8)')}
    }
    set {
      // Probably not the most efficient implementation, but it should work.
      replaceUTF16(utf16.startIndex..<utf16.endIndex, with: EmptyCollection())
      UTF8.parseForward(newValue) {
        replaceUTF16(utf16.endIndex..<utf16.endIndex, with: $0.utf16)
      }
    }
  }

  public typealias FCCNormalizedUTF16View = AnyUInt16UnicodeViewZ
  public var fccNormalizedUTF16: FCCNormalizedUTF16View {
    get {
      ${switch('return FCCNormalizedUTF16View('+wrappingArg+'x.fccNormalizedUTF16)')}
    }
    set {
      replaceUTF16(utf16.startIndex..<utf16.endIndex, with: newValue)
    }
  }

  public typealias UnicodeScalarView = AnyUnicodeScalarUnicodeViewZ
  public var unicodeScalars: UnicodeScalarView {
    get {
      ${switch('return UnicodeScalarView('+wrappingArg+'x.unicodeScalars)')}
    }
    set {
      replaceUTF16(
        utf16.startIndex..<utf16.endIndex, with: newValue.lazy.flatMap {
          UTF16.EncodedScalar($0)
        })
    }
  }

  public typealias CharacterView = AnyCharacterUnicodeViewZ
  public var characters: CharacterView {
    get {
      ${switch('return CharacterView('+wrappingArg+'x.characters)')}
    }
    set {
      replaceUTF16(
        utf16.startIndex..<utf16.endIndex, with: newValue.lazy.flatMap {
          $0.utf16
        })
    }
  }
  
  public func isLatin1() -> Bool { ${switch('return x.isLatin1()')} }
  public func isASCII() -> Bool { ${switch('return x.isASCII()')} }
  public var isKnownLatin1: Bool { ${switch('return x.isKnownLatin1')} }
  public var isKnownASCII: Bool {  ${switch('return x.isKnownASCII')} }
  public var isKnownFCCNormalized: Bool {
    ${switch('return x.isKnownFCCNormalized')}
  }
  public var isKnownFCDForm: Bool { ${switch('return x.isKnownFCDForm')} }
  public var isKnownNFDNormalized: Bool {
    ${switch('return x.isKnownNFDNormalized')}
  }
  public var isKnownNFCNormalized: Bool {
    ${switch('return x.isKnownNFCNormalized')}
  }
}

extension Collection where Iterator.Element == UTF16.CodeUnit {
  internal func _isLatin1() -> Bool {
    return !self.contains { $0 > 0xFF }
  }
  internal var _low8Bits : LazyMapCollection<Self, UInt8> {
    return self.lazy.map { UInt8(truncatingBitPattern: $0) }
  }
}

/// Bit packing
///
/// Packing a sequence of source integer values with a given limited bit width
/// into a single representation integer.
///
/// * Lower-valued elements are assumed to be more common than higher-valued
///   elements.  We want to optimize the representation for storing smaller
///   numbers.
///
/// * Not doing anything fancy like huffman coding here; just direct bit
///   manipulation.
///
/// * We divide the representation up into segments of `bitsPerElement` bits
///   each, starting with the low bit, storing one source value per segment.
///   That means we can't represent any elements with values wider than the bit
///   width.
///
/// * In the general case, we have a partial segment in the high order bits.  
///
/// * We don't want to spend storage on representing a length.  A contiguous run
///   of segments starting with the high order (partial) segment is considered
///   to be empty space, containing no elements.  That means we can't represent
///   any sequence whose last element would be represented as zero; it would be
///   indistinguishable from a missing element.
///
/// * For each source element `e`, we store `(e + 1) & ~(~0 << bitsPerElement)`
///   in its segment.  The result is that we cannot represent a source sequence 
///   ending with the least-common value, and the most common values are
///   still very likely to be representable in any partial segment.
extension UnsignedInteger {
  public init?<C: Collection>(packing source: C, bitsPerElement: Self)
  where C.Iterator.Element : UnsignedInteger {
    // print("Packing \(Array(source)) into \(bitsPerElement) bits per element")
    var r: Self = 0
    var lastSegment: Self = 1
    var shift: Self = 0
    let mask = ~(0 as Self) << bitsPerElement
    for x in source {
      let x1 = numericCast(x) as Self
      if x1 & mask != 0 { return nil } // value too large to represent
      let segment = (x1 &+ 1) & ~mask
      r |= segment << shift
      if r >> shift != segment { return nil } // not enough bits
      lastSegment = segment
      shift += bitsPerElement
    }
    if lastSegment == 0 {  return nil  }
    self = r
  }
}

/// Add the missing shift operators
extension UnsignedInteger {
  // HACK: divide the shift amount into two parts for more-resilient shifting.
  // This will work for the bit packing code I'm currently working on but is not
  // very general (doesn't handle shift amounts >= 2N where N is the number of
  // bits).  Smart shifts from the new-integer-protocols work should solve this
  // in a more principled way.
  public static func <<(lhs: Self, rhs: Self) -> Self {
    let r = rhs.toUIntMax()
    return Self(
      ((lhs.toUIntMax() << (r >> 1)) << ((r + 1) >> 1)) & (~(0 as Self)).toUIntMax())
  }
  public static func >>(lhs: Self, rhs: Self) -> Self {
    let r = rhs.toUIntMax()
    return Self(
      ((lhs.toUIntMax() >> (r >> 1)) >> ((r + 1) >> 1)) & (~(0 as Self)).toUIntMax())
  }
}

//===----------------------------------------------------------------------===//
// WORKAROUND: https://bugs.swift.org/browse/SR-4370
extension UnsignedInteger {
  static func _packing<C: Collection>(_ source: C, bitsPerElement: Self) -> Self?
  where C.Iterator.Element : UnsignedInteger {
    return Self(packing: source, bitsPerElement: bitsPerElement)
  }
}
extension UInt61 {
  public init?<C: Collection>(packing source: C, bitsPerElement: UInt61)
  where C.Iterator.Element : UnsignedInteger {
    guard let me = UInt61._packing(source, bitsPerElement: bitsPerElement) else {
      return nil
    }
    self = me
  }
}
//===----------------------------------------------------------------------===//

struct PackedUnsignedIntegers<
  Representation : UnsignedInteger, Element : UnsignedInteger
> {
  init?<C: Collection>(
    _ c: C,
    bitsPerElement: Representation
  )
  where C.Iterator.Element : UnsignedInteger
  {
    guard let representation = Representation(
      packing: c, bitsPerElement: bitsPerElement) else { return nil }
    self.representation = representation
    self.bitsPerElement = bitsPerElement
  }

  init(representation: Representation, bitsPerElement: Representation) {
    self.representation = representation
    self.bitsPerElement = bitsPerElement
  }
  
  let bitsPerElement: Representation
  let representation: Representation
}

extension PackedUnsignedIntegers : RandomAccessCollection {
  var startIndex: Int { return 0 }
  var endIndex: Int { return count }
  
  var count: Int {
    var result = 0
    var rep = representation
    while rep != 0 {
      rep = rep >> bitsPerElement
      result += 1
    }
    return result
  }
  subscript(i: Int) -> Element {
    var rep = representation
    for _ in 0..<i { rep = rep >> bitsPerElement }
    let mask = ~(0 as Representation) << bitsPerElement
    return numericCast((rep &- 1) & ~mask)
  }
}

extension String.Content {
  public init() { _rep = .utf16(._emptyInstance()) }

  public init(_ ns: _NSStringCore) {
    if let nonTagged = TrueReference(ns) {
      _rep = .cocoa(NSStringPayload(nonTagged))
    }
    else {
      self = String.Content(utf16: _NSStringUTF16(base: ns))
    }
  }
  
  public init<C: Collection>(utf16 source: C)
  where C.Iterator.Element == UTF16.CodeUnit {
    if source.isEmpty {
      self.init()
    }
    else if let x = Inline7or16(utf16: source) {
      self.init(.inline7or16(x))
    }
    else if let x = Inline5or6(utf16: source) {
      self.init(.inline5or6(x))
    }
    else if source.max().unsafelyUnwrapped <= 0xff {
      self.init(
        .latin1(
          _Latin1StringStorage(
            source.lazy.map { UInt8(truncatingBitPattern: $0) })))
    }
    else {
      self.init(.utf16(_UTF16StringStorage(source)))
    }
  }
  
  internal var _storageID: ObjectIdentifier? {
    switch _rep {
    case .utf16(let storage):
      return ObjectIdentifier(storage)
    case .latin1(let storage):
      return ObjectIdentifier(storage)
    case .any(let storage):
      return ObjectIdentifier(storage)
    case .cocoa(let storage):
      // FIXME: don't we want to return nil in the cocoa case, since this is
      // merely used for uniqueness checking and NSString is immutable?
      return ObjectIdentifier(storage.object)
    case .inline5or6, .inline7or16:
      return nil
    }
  }

  /// Replaces the `target` subrange with the given UTF-16 encoded content.
  internal mutating func replaceUTF16<C: Collection>(
    _ target: Range<String.Index>, with replacement_: C
  )  
  where C.Iterator.Element == UTF16.CodeUnit {
    // Pre-count replacement, once.
    let replacement = Counted(replacement_)

    // Try to do in-place replacement
    if _fastPath(replaceUTF16InPlace(target, with: replacement)) {
      return
    }
    // Otherwise, we need to allocate new storage
    let head = utf16[..<target.lowerBound]
    let tail = utf16[target.upperBound...]

    let oldCapacity: UTF16View.IndexDistance
      = numericCast(_latin1?.capacity ?? _utf16?.capacity ?? 0)

    let newCount = head.count + tail.count + numericCast(replacement.count)
    let minimumCapacity = newCount > oldCapacity ? oldCapacity * 2 : 0
    
    // See if we can use 8-bit code units
    if replacement._isLatin1() && (
      isKnownLatin1 || head._isLatin1() && tail._isLatin1()
    ) {
      // FIXME: check to see if we can use the inline5or6 representation.
      let s = _Latin1StringStorage(
        joining: head._low8Bits, replacement._low8Bits, tail._low8Bits,
        minimumCapacity: numericCast(minimumCapacity)
      )
      s.isKnownASCII = !s.contains { $0 > 0x7f }
      _latin1 = s
    }
    else {
      // FIXME: check to see if we can use the inline7or16 representation.
      _utf16 = _UTF16StringStorage(
        joining: head, replacement, tail,
        minimumCapacity: numericCast(minimumCapacity)
      )
    }
  }
  
  internal var isMutable: Bool {
    mutating get {
      defer { _fixLifetime(self) }
      return _storageID?._liveObjectIsUniquelyReferenced() ?? true
    }
  }
  
  internal mutating func replaceUTF16InPlace<C>(
    _ target: Range<String.Index>, with replacement: Counted<C>
  ) -> Bool 
  where C.Iterator.Element == UTF16.CodeUnit {
    if !isMutable { return false }

    let t: Range<Int> = numericCast(target.lowerBound.encodedOffset)
      ..< numericCast(target.upperBound.encodedOffset)

    switch _rep {
    case .utf16(let storage):
      return storage._tryToReplaceSubrange(
        from: t.lowerBound, to: t.upperBound, with: replacement)
    case .latin1(let storage):
      if replacement.contains(where: { $0 > 0xFF }) { return false }
      return storage._tryToReplaceSubrange(
        from: t.lowerBound, to: t.upperBound,
        with: replacement.lazy.map { UInt8(truncatingBitPattern: $0) })
    case .any, .cocoa, .inline5or6, .inline7or16:
      return false
    }
  }
}

extension String : RangeReplaceableCollection {
  
  public init() { content = Content() }
  
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Iterator.Element == Character {
    // Fast path: the incoming characters are UnicodeZ
    if let unicodeReplacement = replacement as? AnyUnicodeZ {
      content.replaceUTF16(target, with: unicodeReplacement.anyContent.anyUTF16)
    }
    else {
      // Slow path: we have to reconstruct UTF-16 from Characters
      content.replaceUTF16(target, with: replacement.lazy.flatMap { $0.utf16 })
    }
  }
}

extension ObjectIdentifier {
  /// Returns true if the object identified by `self` is uniquely referenced.
  ///
  /// - Requires: the object identified by `self` exists.
  /// - Note: will only work when called from a mutating method
  internal func _liveObjectIsUniquelyReferenced() -> Bool {
    var me = self
    return withUnsafeMutablePointer(to: &me) {
      $0.withMemoryRebound(to: AnyObject.self, capacity: 1) {
        _isUnique(&$0.pointee)
      }
    }    
  }
}
//===--- SubString --------------------------------------------------------===//


extension String.SubSequence
  : BidirectionalCollection, BidirectionalCollectionWrapper {
  public typealias Index = Base.Index
  public typealias IndexDistance = Base.IndexDistance
  public typealias Iterator = Base.Iterator
}

extension String.SubSequence
: RangeReplaceableCollection {
  public init() { base = Base() }
  
  // FIXME: figure out how to resolve ambiguities when we try to use the default
  // from BidirectionalCollectionWrapper.
  public mutating func _tryToReplaceSubrange<C: Collection>(
    from targetStart: Index, to targetEnd: Index, with replacement: C
  ) -> Bool
  where C.Iterator.Element == Base.Iterator.Element {
    return base._tryToReplaceSubrange(
      from: targetStart, to: targetEnd,  with: replacement)
  }

  public mutating func replaceSubrange<C: Collection>(
    _ r: Range<Index>, with replacement: C
  )
  where C.Iterator.Element == Base.Iterator.Element {
    return base.replaceSubrange(r,  with: replacement)
  }
}

/*
extension String.SubSequence : UnicodeZ {
  public struct Content {
    var base: String.Content
  }
  public var content: Content {
    return base.base.content[base.bounds]
  }
}

public typealias SubString = String.SubSequence

extension SubString.Content : AnyUnicodeContentZ {
  var isKnownLatin1: Bool { return base.isKnownLatin1 }
  var isKnownASCII: Bool { return base.isKnownASCII }
  var isKnownFCCNormalized: Bool { return base.isKnownFCCNormalized }
  var isKnownFCDForm: Bool { return base.isKnownFCDForm }
  var isKnownNFDNormalized: Bool { return base.isKnownNFDNormalized }
  var isKnownNFCNormalized: Bool { return base.isKnownNFCNormalized }
}

extension SubString.Content : UnicodeContentZ {
  /// A type that presents the string's UTF-16 code units
  associatedtype UTF16View : UnicodeViewZ
  // where Iterator.Element == UInt16

  /// The string's UTF-16 code units.
  ///
  /// Note: this view may contain encoding errors, if the underlying encoding is
  /// UTF16 and the source had encoding errors.
  var utf16: UTF16View { get }

  /// A type that presents the string's UTF-8 code units
  associatedtype UTF8View : UnicodeViewZ
  // where Iterator.Element == UInt8

  /// The string's UTF-8 code units.
  ///
  /// Note: this view may contain encoding errors, if the underlying encoding is
  /// UTF8 and the source had encoding errors.
  var utf8: UTF8View { get }

  /// A type that presents an FCC-normalized view of the string
  associatedtype FCCNormalizedUTF16View : UnicodeViewZ
  // where Iterator.Element == UInt16

  /// An FCC-normalized view of the string
  var fccNormalizedUTF16: FCCNormalizedUTF16View { get }

  associatedtype CharacterView : UnicodeViewZ
  // where Iterator.Element == Character

  var characters: CharacterView { get }

  /// A type that presents the string's unicode scalar values
  associatedtype UnicodeScalarView : UnicodeViewZ
  // where Iterator.Element == UnicodeScalar

  var unicodeScalars: UnicodeScalarView { get }
}
*/
//===--- Literal Support --------------------------------------------------===//

extension String : ExpressibleByUnicodeScalarLiteral {
  /// Creates an instance initialized to the given UnicodeZ scalar value.
  ///
  /// Do not call this initializer directly. It may be used by the compiler when
  /// you initialize a string using a string literal that contains a single
  /// UnicodeZ scalar value.
  public init(unicodeScalarLiteral value: UnicodeScalar) {
    content = Content(utf16: value.utf16)
  }
}

extension String : ExpressibleByExtendedGraphemeClusterLiteral {
  /// Creates an instance initialized to the given extended grapheme cluster
  /// literal.
  ///
  /// Do not call this initializer directly. It may be used by the compiler when
  /// you initialize a string using a string literal containing a single
  /// extended grapheme cluster.
  public init(extendedGraphemeClusterLiteral value: Character) {
    content = Content(utf16: value.utf16)
  }
}

extension String : ExpressibleByStringLiteral {
  public init(stringLiteral value: StaticString) {
    content = value.withUTF8Buffer {
      Content(
        utf16: _UnicodeViews($0, ValidUTF8.self).transcoded(to: UTF16.self))
    }
  }
}

//===--- CustomStringConvertible/CustomDebugStringConvertible -------------===//
extension String : CustomStringConvertible {
  // TODO: once this replaces Swift.String this needs to revert
  // back to the trivial implementation of returning self
  public var description: Swift.String {
    return Swift.String(self)
  }
}

extension String : CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    var result = "\""
    for us in self.content.unicodeScalars {
      result += us.escaped(asASCII: false)
    }
    result += "\""
    return result
  }
}

//===--- Comparable/Hashable ----------------------------------------------===//
extension String : Comparable {
  public static func < (lhs: String, rhs: String) -> Bool {
    return lhs.content.fccNormalizedUTF16.lexicographicallyPrecedes(
      rhs.content.fccNormalizedUTF16
    )
  }
  public static func == (lhs: String, rhs: String) -> Bool {
    return lhs.content.fccNormalizedUTF16.elementsEqual(
      rhs.content.fccNormalizedUTF16
    )
  }
}

extension String : Hashable {
  public var hashValue : Int {
    var hasher = _SipHash13Context(key: _Hashing.secretKey)
    for x in content.fccNormalizedUTF16 { hasher.append(x) }
    let resultBits = hasher.finalizeAndReturnHash()
#if arch(i386) || arch(arm)
    return Int(truncatingBitPattern: resultBits)
#elseif arch(x86_64) || arch(arm64) || arch(powerpc64) || arch(powerpc64le) || arch(s390x)
    return Int(Int64(bitPattern: resultBits))
#endif
  }
}

//===--- CString Interop --------------------------------------------------===//
extension String {
  /// Constructs a `String` having the same contents as `nulTerminatedUTF8`.
  ///
  /// - Parameter nulTerminatedUTF8: a sequence of contiguous UTF-8 encoded 
  ///   bytes ending just before the first zero byte (NUL character).
  init(cString nulTerminatedUTF8: UnsafePointer<CChar>) {
    // FIXME: is UTF8 the right default way to interpret a C string?  Cocoa
    // makes use of a "system encoding" that might be relevant.
    
    let count = UTF8._nullCodeUnitOffset(in: nulTerminatedUTF8)
    content = nulTerminatedUTF8.withMemoryRebound(
      to: UTF8.CodeUnit.self, capacity: count
    ) {
      Content(
        utf16: _UnicodeViews(
          UnsafeBufferPointer(start: $0, count: count),
          UTF8.self).transcoded(to: UTF16.self))
    }
  }
  
  /// Constructs a `String` having the same contents as `nulTerminatedCodeUnits`.
  ///
  /// - Parameter nulTerminatedCodeUnits: a sequence of contiguous code units in
  ///   the given `encoding`, ending just before the first zero code unit.
  /// - Parameter encoding: describes the encoding in which the code units
  ///   should be interpreted.
  init<Encoding: UnicodeEncoding>(
    cString nulTerminatedCodeUnits:
    UnsafePointer<Encoding.EncodedScalar.Iterator.Element>,
    encoding: Encoding.Type
  )
  where Encoding.EncodedScalar.Iterator.Element : UnsignedInteger {
    let count = Encoding._nullCodeUnitOffset(in: nulTerminatedCodeUnits)
    let source = UnsafeBufferPointer(
      start: nulTerminatedCodeUnits, count: count)
    content = Content(
      utf16: _UnicodeViews(source, Encoding.self).transcoded(to: UTF16.self))
  }
 
  /// Invokes the given closure on the contents of the string, represented as a
  /// pointer to a null-terminated sequence of UTF-8 code units.
  func withCString<Result>(
    _ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result {
    /*
    // FIXME: add support for writing zero into the end of existing latin-1
    // storage.
    if let l = content._latin1, l.isASCII() {
      return l.withExistingUnsafeBuffer(body)!
    }
    */
    // FIXME: add a utf8 view to UnicodeContentZ so this can be faster in many
    // cases.
    var result = ContiguousArray<CChar>()
    let source = Counted(content.utf8)
    result.reserveCapacity(numericCast(source.count + 1))
    result.append(contentsOf: source.lazy.map { numericCast($0) })
    result.append(0)
    return try result.withUnsafeBufferPointer {
      try body($0.baseAddress)
    }
  }
}

//===--- StringCore -------------------------------------------------------===//
extension String {
  // FIXME: this is a kludgy method, but then again, we want to wean everything
  // off of it...
  public var _core: _StringCore {
    get {
      let _cocoaString = self as NSString
      return _StringCore(
        baseAddress: nil,
        count: _cocoaString.length,
        elementShift: 1, //isUTF16 ? 1 : 0,
        hasCocoaBuffer: true,
        owner: _cocoaString)
    }
    set {
      self = String(content: String.Content(utf16: newValue))
    }
  }
}

//===--- Objective C Bridging ---------------------------------------------===//
import Foundation
extension String : _ObjectiveCBridgeable {
  internal static func _withSmallUTF16<R, C: Collection>(
    _ c: C,
    body: (UnsafeBufferPointer<UTF16.CodeUnit>) throws->R
  ) rethrows -> R
  where C.Iterator.Element == UTF16.CodeUnit
  {
    let z: UTF16.CodeUnit = 0
    var buffer = (z,z,z,z,z,z,z,z,z,z,z,z)
    let capacity = MemoryLayout.size(ofValue: buffer)
      / MemoryLayout.size(ofValue: buffer.0)
    return try withUnsafeMutablePointer(to: &buffer.0) { p in
      var (tail, count) = c._copyContents(
        initializing: UnsafeMutableBufferPointer(start: p, count: capacity))
      _debugPrecondition(tail.next() == nil)
      return try body(UnsafeBufferPointer(start: p, count: count))
    }
  }
  
  @_semantics("convertToObjectiveC")
  public func _bridgeToObjectiveC() -> NSString {
    switch content._rep {
    case .latin1(let x): return unsafeDowncast(x, to: NSString.self)
    case .utf16(let x): return unsafeDowncast(x, to: NSString.self)
    case .cocoa(let x): return unsafeDowncast(x.object, to: NSString.self)
    case .any(let x): return unsafeDowncast(
        _UTF16StringStorage(x.utf16), to: NSString.self)
    case .inline5or6(let x):
      return String._withSmallUTF16(x.utf16) {
        NSString(characters: $0.baseAddress, length: $0.count)
      }
    case .inline7or16(let x):
      return String._withSmallUTF16(x.utf16) {
        NSString(characters: $0.baseAddress, length: $0.count)
      }
    }
  }

  public static func _forceBridgeFromObjectiveC(
    _ x: NSString,
    result: inout String?
  ) {
    result = _unconditionallyBridgeFromObjectiveC(x)
  }

  public static func _conditionallyBridgeFromObjectiveC(
    _ x: NSString,
    result: inout String?
  ) -> Bool {
    self._forceBridgeFromObjectiveC(x, result: &result)
    return result != nil
  }

  public static func _unconditionallyBridgeFromObjectiveC(
    _ source: NSString?
  ) -> String {
    // `nil` has historically been used as a stand-in for an empty
    // string; map it to an empty string.
    if _slowPath(source == nil) { return String() }
    return String(
      content: String.Content(
        unsafeBitCast(
          source!.copy() as! NSString, to: _NSStringCore.self)))
  }
}


//===----------------------------------------------------------------------===//
//===--- Tests ------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
var suite = TestSuite("AnyUnicodeZ")

suite.test("UInt61.packing") {
//  let five: UInt61 = 5
  // Can't represent 32 as a 5-bit value
  expectNil(UInt61(packing: CollectionOfOne(32 as UInt), bitsPerElement: 5))
  
  // The last value in the collection can't have all bits set because we can't
  // distinguish that from "no more elements are left"
  expectNil(UInt61(packing: CollectionOfOne(31 as UInt), bitsPerElement: 5))

  expectEqual(
    31,
    UInt61(packing: CollectionOfOne(30 as UInt), bitsPerElement: 5))

  expectEqual(
    1,
    UInt61(packing: CollectionOfOne(0 as UInt), bitsPerElement: 5))

  expectEqual(
    0b11111_00000,
    UInt61(packing: [31, 30] as [UInt], bitsPerElement: 5))

  expectNil(UInt61(packing: [31, 30, 31] as [UInt], bitsPerElement: 5))

  expectEqual(
    0b11111_00000_11111_00000,
    UInt61(packing: [31, 30, 31, 30] as [UInt], bitsPerElement: 5))

  let primesAndMore: [UInt] = [31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2, 1, 0]
  expectEqual(
    0b1_00010_00011_00100_00110_01000_01100_01110_10010_10100_11000_11110_00000,
    UInt61(packing: primesAndMore, bitsPerElement: 5))
  
  if let c = expectNotNil(
    PackedUnsignedIntegers<UInt61, UInt>(primesAndMore, bitsPerElement: 5)
  ) {
    expectEqualSequence(primesAndMore, Array(c))
  }
  
  // There's only 1 bit left in the high-order partial segment.
  expectNil(
    UInt61(packing:
      [31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2, 1, 1] as [UInt],
      bitsPerElement: 5))
}

extension String.Content {
  var bitsPerCodeUnit: Int {
    switch _rep {
    case .utf16: return 16
    case .latin1: return 8
    case .cocoa(let n): return n.isKnownASCII ? 8 : 16
    case .any: return 16
    case .inline7or16(let x): return x.bitsPerElement
    case .inline5or6(let x):  return x.bitsPerElement
    }
  }
}

suite.test("Content.Packing") {
  // We can store up to 4 UTF16 code units in the inline7or16 case
  var c = String.Content(utf16: "a".utf16)
  expectEqualSequence("a".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(16, c.bitsPerCodeUnit)
  
  c = String.Content(utf16: "ab".utf16)
  expectEqualSequence("ab".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(16, c.bitsPerCodeUnit)
  
  c = String.Content(utf16: "abc".utf16)
  expectEqualSequence("abc".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(16, c.bitsPerCodeUnit)
  
  c = String.Content(utf16: "abcd".utf16)
  expectEqualSequence("abcd".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(16, c.bitsPerCodeUnit)
  
  c = String.Content(utf16: "ab\u{ffe9}d".utf16)
  expectEqualSequence("ab\u{ffe9}d".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(16, c.bitsPerCodeUnit)

  // If the last code unit is sufficiently high-valued, we overflow the
  // high-order partial segment and fall back to dynamic storage
  c = String.Content(utf16: "abc\u{ffe9}".utf16)
  expectEqualSequence("abc\u{ffe9}".utf16, Array(c.utf16))
  expectNotNil(c._utf16)

  // If it's all ASCII, we may fit in the inline 7 case.
  c = String.Content(utf16: "abcde".utf16)
  expectEqualSequence("abcde".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(7, c.bitsPerCodeUnit)

  c = String.Content(utf16: "abcdefgh".utf16)
  expectEqualSequence("abcdefgh".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(7, c.bitsPerCodeUnit)

  // A sufficiently low-valued code unit will fit in the high-order partial
  // segment
  c = String.Content(utf16: "abcdefgh.".utf16)
  expectEqualSequence("abcdefgh.".utf16, Array(c.utf16))
  expectNotNil(c._inline7or16)
  expectEqual(7, c.bitsPerCodeUnit)

  // Higher than that and we fall back to a 6-bit representation
  c = String.Content(utf16: "abcdefghi".utf16)
  expectEqualSequence("abcdefghi".utf16, Array(c.utf16))
  expectNotNil(c._inline5or6)
  expectEqual(6, c.bitsPerCodeUnit)

  c = String.Content(utf16: "abcdefghij".utf16)
  expectEqualSequence("abcdefghij".utf16, Array(c.utf16))
  expectNotNil(c._inline5or6)
  expectEqual(6, c.bitsPerCodeUnit)

  // If it gets too long for 6 bits it falls over into 5 bits per character
  // Note "b" falls outside the common characters representable in 5 bits
  c = String.Content(utf16: "aecdefghij0".utf16)
  expectEqualSequence("aecdefghij0".utf16, Array(c.utf16))
  expectNotNil(c._inline5or6)
  expectEqual(5, c.bitsPerCodeUnit)

  c = String.Content(utf16: "aecdefghij01".utf16)
  expectEqualSequence("aecdefghij01".utf16, Array(c.utf16))
  expectNotNil(c._inline5or6)
  expectEqual(5, c.bitsPerCodeUnit)

  // After 12 characters, we fall back to deep latin-1
  c = String.Content(utf16: "aecdefghij010".utf16)
  expectEqualSequence("aecdefghij010".utf16, Array(c.utf16))
  expectNotNil(c._latin1)
  expectEqual(8, c.bitsPerCodeUnit)
}


let sample = "abcdefghijklmnopqrstuvwxyz\n"
  + "🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸\n"
  + "Σὲ 👥🥓γνωρίζω ἀπὸ τὴν κόψη χαῖρε, ὦ χαῖρε, ᾿Ελευθεριά!\n"
  + "Οὐχὶ ταὐτὰ παρίσταταί μοι γιγνώσκειν, ὦ ἄνδρες ᾿Αθηναῖοι,\n"
  + "გთხოვთ ახლავე გაიაროთ რეგისტრაცია UnicodeZ-ის მეათე საერთაშორისო\n"
  + "Зарегистрируйтесь сейчас на Десятую Международную Конференцию по\n"
  + "  ๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่\n"
  + "ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ"

suite.test("MemoryLayout") {
  expectEqual(8, MemoryLayout<String>.size)
  expectEqual(8, MemoryLayout<String>.stride)
}

suite.test("InplaceViewMutation") {
  var s = String(sample)
  var s1 = s
  expectEqualSequence(s.content.unicodeScalars, s1.content.unicodeScalars)
  s.content.unicodeScalars.removeLast(1)
  expectEqualSequence(
    s.content.unicodeScalars, s1.content.unicodeScalars.dropLast()
  )
}

suite.test("ViewValueSemantics") {
  var sharesBuffer1 = String(sample).content.utf16
  let sharesBuffer2 = sharesBuffer1
  var snapshot = Array(sharesBuffer2)

  // Unwrap the view
  let wrapped = sharesBuffer1.base2 as! AnyUInt16UnicodeViewZ.Adapter<
    RandomAccessUnicodeView<_UTF16StringStorage>>
  
  // Tunnel all the way to the underlying storage, which has reference
  // semantics.  FIXME: there should be no way for the user to do this!
  var storage: _UTF16StringStorage = wrapped.base.base

  // Make a mutation there, and expect both views to reflect that.
  storage.removeLast(1) 
  expectEqualSequence(snapshot.dropLast(), storage)
  expectEqualSequence(snapshot.dropLast(), sharesBuffer2) 
  expectEqualSequence(snapshot.dropLast(), sharesBuffer1)

  snapshot.removeLast()
  
  // However, mutating sharesBuffer1 makes a copy rather than modifying storage
  let oldCount = sharesBuffer1.count
  expectEqual(oldCount, numericCast(storage.count))
  sharesBuffer1.removeLast()
  expectEqual(oldCount, numericCast(storage.count))
  expectEqual(oldCount - numericCast(1), sharesBuffer1.count)
  expectEqualSequence(snapshot, storage) 
  expectEqualSequence(snapshot, sharesBuffer2) 
  expectEqualSequence(snapshot.dropLast(), Array(sharesBuffer1))
  // FIXME: something in the collection forwarding stack is not forwarding
  // _tryToReplaceSubrange, or this test would fail.  That means we're probably
  // missing an optimization when it actually *is* OK to mutate the storage in
  // place.
}

suite.test("UTF16/smoke") {
  var s = String(sample)
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
  
  s.replaceSubrange(
    s.index(atOffset: 3)..<s.index(atOffset: 10), with: "BRAK")
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())

  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: "---bl\u{f8}\u{f8}g---"
  )
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
}

suite.test("Latin1/smoke") {
  var s = String(
    sample.unicodeScalars.lazy.filter { $0.value < 0x100 }.map {
      Character($0)
    })
  expectNotNil(s.content._latin1)
  expectTrue(s.content.isKnownLatin1)
  expectTrue(s.content.isLatin1())
  expectEqual(!s.content.utf16.contains { $0 > 0x7f }, s.content.isKnownASCII)
  expectEqual(!s.content.utf16.contains { $0 > 0x7f }, s.content.isASCII())
  
  s.replaceSubrange(s.index(atOffset: 3)..<s.index(atOffset: 10), with: "BRAK")
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))
  expectTrue(s.content.isKnownLatin1)
  expectTrue(s.content.isLatin1())
  expectTrue(s.content.isKnownASCII)
  expectTrue(s.content.isASCII())
  
  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: "---bl\u{f8}\u{f8}g---"
  )
  expectNotNil(s.content._latin1)
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
  expectTrue(s.content.isKnownLatin1)
  expectTrue(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
  
  s.replaceSubrange(
    s.index(atOffset: 11)..<s.index(atOffset: 11),
    with: "🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸")
  expectNil(s.content._latin1)
  expectFalse(s.content.isKnownLatin1)
  expectFalse(s.content.isLatin1())
  expectFalse(s.content.isKnownASCII)
  expectFalse(s.content.isASCII())
  expectEqual(
    "abcBR---blø🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸øg---Kklm",
    Swift.String(s[..<s.index(atOffset: 25)]))
}

suite.test("RangeReplaceable/UTF16/FastPath") {
  // Exercise the case where the source text is-a UnicodeZ.
  var s = String(sample)
  s.replaceSubrange(
    s.index(atOffset: 3)..<s.index(atOffset: 10), with: String("BRAK"))
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))

  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: String("---bl\u{f8}\u{f8}g---")
  )
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
}

suite.test("RangeReplaceable/Latin1/FastPath") {
  // Exercise the case where the source text is-a UnicodeZ.
  var s = String(
    sample.unicodeScalars.lazy.filter { $0.value < 0x100 }.map {
      Character($0)
    })
  s.replaceSubrange(
    s.index(atOffset: 3)..<s.index(atOffset: 10), with: String("BRAK"))
  expectEqual(
    "abcBRAKklmnopqrstuvw", Swift.String(s[..<s.index(atOffset: 20)]))

  let s1 = s
  // ensure that we modify a non-unique buffer this time
  defer { _fixLifetime(s1) } 
  
  s.replaceSubrange(
    s.index(atOffset: 5)..<s.index(atOffset: 6),
    with: String("---bl\u{f8}\u{f8}g---")
  )
  expectEqual(
    "abcBR---bl\u{f8}\u{f8}g---Kklmnopqr",
    Swift.String(s[..<s.index(atOffset: 25)]))
}

suite.test("Bidirectional/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeViewZ(${wrappingArg}
    _UnicodeViews(Array(sample.utf16), ValidUTF16.self).scalars)
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedOffset = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedOffset
    expectLT(lastEncodedOffset, o)
    lastEncodedOffset = o
  }
}

suite.test("RandomAccess/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeViewZ(${wrappingArg}
    RandomAccessUnicodeViewZ(Array(sample.unicodeScalars)))
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedOffset = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedOffset
    expectLT(lastEncodedOffset, o)
    lastEncodedOffset = o
  }
}

suite.test("CharacterView") {
  // FIXME: precondition checks in Character prevent us from trying this last
  // one.
  let s = "🇸🇸🇬🇱abc🇱🇸🇩🇯🇺🇸\nΣὲ 👥🥓γ͙᷏̃̂᷀νω" // + "👩‍❤️‍👩"
  let a: [Character] = [
    "🇸🇸", "🇬🇱", "a", "b", "c", "🇱🇸", "🇩🇯", "🇺🇸", "\n",
    "Σ", "ὲ", " ", "👥", "🥓", "γ͙᷏̃̂᷀", "ν", "ω"
  ] // + "👩‍❤️‍👩"

  // FIXME: the generic arguments should be deducible, but aren't; <rdar://30323161>
  let v8 = _UnicodeViews<Array<UInt8>, UTF8>.CharacterView(Array(s.utf8), UTF8.self)
  expectEqual(a, Array(v8))

  // FIXME: We need to wrap s.utf16 in Array because of <rdar://30386193> Unaccountable link errors
  // FIXME: the generic arguments should be deducible; <rdar://30323161>
  let v16 = _UnicodeViews<Array<UInt16>, UTF16>.CharacterView(Array(s.utf16), UTF16.self)
  expectEqual(a, Array(v16))

  expectEqual(v8.reversed(), a.reversed())
  expectEqual(v16.reversed(), a.reversed())

  // This one demonstrates that we get grapheme breaking of regional indicators
  // (RI) right, while Swift 3 string does not.
  expectFalse(a.elementsEqual(s.characters))
}

suite.test("basic") {
  let s = sample
  let s32 = s.unicodeScalars.lazy.map { $0.value }
  let s16 = Array(s.utf16)
  let s8 = Array(s.utf8)
  let s16to32 = _UnicodeViews.TranscodedView(s16, from: UTF16.self, to: UTF32.self)
  let s16to8 = _UnicodeViews.TranscodedView(s16, from: UTF16.self, to: UTF8.self)
  let s8to16 = _UnicodeViews.TranscodedView(s8, from: UTF8.self, to: UTF16.self)
  let s8Vto16 = _UnicodeViews.TranscodedView(s8, from: ValidUTF8.self, to: UTF16.self)
  expectTrue(s32.elementsEqual(s16to32))
  expectTrue(s8.elementsEqual(s16to8))
  expectTrue(s16.elementsEqual(s8to16))
  expectTrue(s16.elementsEqual(s8Vto16))

  expectTrue(s32.reversed().elementsEqual(s16to32.reversed()))
  expectTrue(s8.reversed().elementsEqual(s16to8.reversed()))
  expectTrue(s16.reversed().elementsEqual(s8to16.reversed()))
  expectTrue(s16.reversed().elementsEqual(s8Vto16.reversed()))
}

suite.test("literals") {
  let ascii: String = "abcdef"
  expectEqual(6, ascii.count)
  expectEqualSequence("abcdef" as Swift.String, ascii)
  let unicode: String = "abcdef🦊"
  expectEqual(7, unicode.count)
  expectEqualSequence("abcdef🦊" as Swift.String, unicode)
}

suite.test("printing") {
  let s: String = "a \"string\" with \"quotes\""
  expectEqual(
    "a \"string\" with \"quotes\"", s.description)
  expectEqual(
    "a \"string\" with \"quotes\"".debugDescription, s.debugDescription)
}

suite.test("character") {
  let s1: String = "Héllo, 🌍!"
  var s2: Swift.String = ""
  for c in s1 {
    s2.append(c)
  }
  // expectTrue(s1.elementsEqual(s2.characters))
  expectEqual(9, s1.count)

  // emoji with skin tone should be 1 character (are 2 in Swift 3)
  let skinTone: String = "✌🏾"
  expectEqual(1, skinTone.count)

  let couple: String = "abc👩‍❤️‍👩def"
  expectEqual(7, couple.count)
}

suite.test("string-compare-hash") {
  let s1: String = "abcdez"
  let s2: String = "abcdfz"
  let s3: String = "abcde\u{304}z"
  let s4: String = "abcd\u{113}z"

  expectEqual(s1, s1)
  expectEqual(s2, s2)
  expectEqual(s3, s3)
  expectEqual(s4, s4)

  expectLT(s1, s2)
  expectNotEqual(s1.hashValue, s2.hashValue)
  expectLT(s2, s3)
  expectNotEqual(s2.hashValue, s3.hashValue)
  expectEqual(s3, s4)
  expectEqual(s3.hashValue, s4.hashValue)
}

suite.test("replaceSubrange") {
  let initial: String = "hello world!"

  let cases: [(Int64, String, String, String)] = 
    [(0, "hello", "goodbye", "goodbye world!"),        // Edit start
     (8, "world!", "moon?", "goodbye moon?"),          // Edit end
     (4, "bye", " night", "good night moon?"),         // Edit middle
     (4, "", " 🦊🦊🦊", "good 🦊🦊🦊 night moon?")]  // wide Characters

  var testSubject = initial;
  for (start, needle, replacement, result) in cases {
    let startIndex = testSubject.index(atOffset: start)
    
    testSubject.replaceSubrange(
      startIndex..<testSubject.index(startIndex, offsetBy: needle.count),
      with: replacement)
    
    expectEqual(testSubject, result)
  }

  // Make sure the initial value wasn't mutated
  expectEqual(initial, "hello world!")

  // Check implicit RangeReplaceable stuff works
  var hello: String = "Hello!"
  hello.removeLast()
  let newElements: String = ", 🌎!"
  hello += newElements
  expectEqual(hello, "Hello, 🌎!")
}

suite.test("cstring") {
  let s1: String = "abracadabra"
  expectEqual(s1.withCString(strlen), 11)
  let s2: String = "3.14159"
  expectEqual(3.14159,s2.withCString(atof))
  
  let s3: Swift.String = "some string"
  s3.withCString {
    let s = String(cString: $0)
    expectEqual("some string", s)
  }

  let utf16 = Array(s3.utf16) + [0]
  let s4 = utf16.withUnsafeBufferPointer {
    String(cString: $0.baseAddress, encoding: UTF16.self)
  }
  expectEqual(s4, "some string")
}

suite.test("fcc-normalized-view") {
  let a: UInt16 = 0x0061
  let aTic: UInt16 = 0x00e0
  let aBackTic: UInt16 = 0x00e1
  typealias UTF16String = _UnicodeViews<[UInt16], UTF16>
  // typealias NormalizedView = FCCNormalizedUTF16View_2<[UInt16], UTF16>

  // Helper functions, eagerly forms arrays of the forwards and reverse
  // FCC normalized UTF16 code units
  func fccNormView(_ codeUnits: [UInt16])
    -> (forward: [UInt16], reversed: [UInt16]) {
    let view = UTF16String(codeUnits).fccNormalizedUTF16
    return (forward: Array(view),
            reversed: Array(view.reversed()))
  }

  // Test canonical equivalence for:
  //   1) a + ̀ + ́ == à + ́
  //   2) a + ́ + ̀ == á + ̀
  // BUT, the two are distinct, #1 != #2
  do {
    let str1form1 = [a, 0x0300, 0x0301]
    let str1form2 = [aTic, 0x0301]
    let str2form1 = [a, 0x0301, 0x0300]
    let str2form2 = [aBackTic, 0x0300]

    let (norm1_1, norm1_1rev) = fccNormView(str1form1)
    let (norm1_2, norm1_2rev) = fccNormView(str1form2)
    let (norm2_1, norm2_1rev) = fccNormView(str2form1)
    let (norm2_2, norm2_2rev) = fccNormView(str2form2)

    expectEqualSequence(norm1_1, norm1_2)
    expectEqualSequence(norm2_1, norm2_2)
    for (cu1, cu2) in zip(norm1_1, norm2_1) {
      expectNotEqual(cu1, cu2)
    }
    expectEqualSequence(norm1_1rev, norm1_2rev)
    expectEqualSequence(norm2_1rev, norm2_2rev)
    for (cu1, cu2) in zip(norm1_1rev, norm2_1rev) {
      expectNotEqual(cu1, cu2)
    }
  }

  // Test canonical equivalence, and non-combining-ness of FCC for:
  //   1) a + ̖ + ̀ == à + ̖ == a + ̀ + ̖
  //   All will normalize under FCC as a + ̖ + ̀
  do {
    let form1 = [a, 0x0316, 0x0300]
    let form2 = [a, 0x0300, 0x0316]
    let form3 = [aTic, 0x0316]

    let (norm1, norm1rev) = fccNormView(form1)
    let (norm2, norm2rev) = fccNormView(form2)
    let (norm3, norm3rev) = fccNormView(form3)

    expectEqualSequence(norm1, norm2)
    expectEqualSequence(norm2, norm3)
    expectEqualSequence(norm1rev, norm2rev)
    expectEqualSequence(norm2rev, norm3rev)

    // Form 1 is already in FCC
    expectEqualSequence(norm3, form1)
    expectEqualSequence(norm3rev, form1.reversed())
  }

  // Test non-start first scalars
  do {
    let form1 = [0x0300, a, 0x0300]
    let form2 = [0x0300, aTic] // In FCC normal form
    let (norm1, norm1rev) = fccNormView(form1)
    let (norm2, norm2rev) = fccNormView(form2)

    // Sanity check existing impl
    expectEqualSequence(norm1, norm2)
    expectEqualSequence(norm1rev, norm2rev)
    expectEqualSequence(norm1, form2)
  }
}

suite.test("_StringCore") {
  let oldStr : Swift.String = "abcdefg"
  let newStr : String = "abcdefg"
  expectEqualSequence(oldStr._core, newStr._core)

  // abcdefg ==> abcdef
  var str = String()
  str._core = newStr._core.dropLast()
  expectEqualSequence(Swift.String("abcdef")!._core, str._core)

  // abcdef ==> abc̀df
  var idx = str._core.startIndex
  idx = str._core.index(idx, offsetBy: 3)
  str._core.insert(contentsOf: [0x0300], at: idx)
  idx = str._core.index(idx, offsetBy: 2)
  str._core.remove(at: idx)
  expectEqualSequence(Swift.String("abc̀df")!._core, str._core)
}

suite.test("bridging") {
  do {
    let s: String = "abc\n🇸🇸🇬🇱🇱🇸🇩🇯🇺🇸\nΣὲ 👥🥓γνωρίζω\nგთხოვთ\nงบู๊กู้ขึ้นม่\nᚹᛖᛥᚫ"
    let n = s as NSString
    // Generalized NSString representation
    expectNotNil(TrueReference(n))
    let s2 = n as String
    expectEqual(s, s2)
  }

  do {
    let s: String = "ace of case"
    expectNotNil(s.content._inline5or6) // 5-bit per character inline buffer
    let n = s as NSString
    expectNil(TrueReference(n))         // 5-bit per character tagged NSString
    let s2 = n as String
    expectEqual(s, s2)
  }
  
  do {
    let s: String = "UL2O85UL2" 
    expectNotNil(s.content._inline5or6) // 6-bit per character inline buffer
    let n = s as NSString
    expectNil(TrueReference(n))         // 6-bit per character tagged NSString
    let s2 = n as String
    expectEqual(s, s2)
  }

  do {
    let s: String = "ZZZZ"              
    expectNotNil(s.content._inline7or16) // 7 bit ASCII inline buffer
    let n = s as NSString
    expectNil(TrueReference(n))          // ASCII tagged NSString representation
    let s2 = n as String
    expectEqual(s, s2)
  }

  do {
    let s: String = "¢¤¥"          // UTF16 inline buffer
    expectNotNil(s.content._inline7or16)
    let n = s as NSString
    expectNotNil(TrueReference(n)) // No non-ASCII tagged NSStrings, it seems
    let s2 = n as String
    expectEqual(s, s2)
  }
}

suite.test("AnyUInt16UnicodeViewZ.DoubleWrapping") {
  let s: String = "Bouffant Hairdo"
  let u1 = s.content.utf16
  let u2 = AnyUInt16UnicodeViewZ(${wrappingArg}u1)
  expectEqual(type(of: u1.base), type(of: u2.base))
}

runAllTests()

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
